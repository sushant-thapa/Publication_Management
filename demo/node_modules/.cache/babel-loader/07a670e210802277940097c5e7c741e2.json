{"ast":null,"code":"/**\n * Manage access to data, be it to find, update or remove it\n */\nvar model = require('./model'),\n    _ = require('underscore');\n/**\n * Create a new cursor for this collection\n * @param {Datastore} db - The datastore this cursor is bound to\n * @param {Query} query - The query this cursor will operate on\n * @param {Function} execFn - Handler to be executed after cursor has found the results and before the callback passed to find/findOne/update/remove\n */\n\n\nfunction Cursor(db, query, execFn) {\n  this.db = db;\n  this.query = query || {};\n\n  if (execFn) {\n    this.execFn = execFn;\n  }\n}\n/**\n * Set a limit to the number of results\n */\n\n\nCursor.prototype.limit = function (limit) {\n  this._limit = limit;\n  return this;\n};\n/**\n * Skip a the number of results\n */\n\n\nCursor.prototype.skip = function (skip) {\n  this._skip = skip;\n  return this;\n};\n/**\n * Sort results of the query\n * @param {SortQuery} sortQuery - SortQuery is { field: order }, field can use the dot-notation, order is 1 for ascending and -1 for descending\n */\n\n\nCursor.prototype.sort = function (sortQuery) {\n  this._sort = sortQuery;\n  return this;\n};\n/**\n * Add the use of a projection\n * @param {Object} projection - MongoDB-style projection. {} means take all fields. Then it's { key1: 1, key2: 1 } to take only key1 and key2\n *                              { key1: 0, key2: 0 } to omit only key1 and key2. Except _id, you can't mix takes and omits\n */\n\n\nCursor.prototype.projection = function (projection) {\n  this._projection = projection;\n  return this;\n};\n/**\n * Apply the projection\n */\n\n\nCursor.prototype.project = function (candidates) {\n  var res = [],\n      self = this,\n      keepId,\n      action,\n      keys;\n\n  if (this._projection === undefined || Object.keys(this._projection).length === 0) {\n    return candidates;\n  }\n\n  keepId = this._projection._id === 0 ? false : true;\n  this._projection = _.omit(this._projection, '_id'); // Check for consistency\n\n  keys = Object.keys(this._projection);\n  keys.forEach(function (k) {\n    if (action !== undefined && self._projection[k] !== action) {\n      throw new Error(\"Can't both keep and omit fields except for _id\");\n    }\n\n    action = self._projection[k];\n  }); // Do the actual projection\n\n  candidates.forEach(function (candidate) {\n    var toPush;\n\n    if (action === 1) {\n      // pick-type projection\n      toPush = {\n        $set: {}\n      };\n      keys.forEach(function (k) {\n        toPush.$set[k] = model.getDotValue(candidate, k);\n\n        if (toPush.$set[k] === undefined) {\n          delete toPush.$set[k];\n        }\n      });\n      toPush = model.modify({}, toPush);\n    } else {\n      // omit-type projection\n      toPush = {\n        $unset: {}\n      };\n      keys.forEach(function (k) {\n        toPush.$unset[k] = true;\n      });\n      toPush = model.modify(candidate, toPush);\n    }\n\n    if (keepId) {\n      toPush._id = candidate._id;\n    } else {\n      delete toPush._id;\n    }\n\n    res.push(toPush);\n  });\n  return res;\n};\n/**\n * Get all matching elements\n * Will return pointers to matched elements (shallow copies), returning full copies is the role of find or findOne\n * This is an internal function, use exec which uses the executor\n *\n * @param {Function} callback - Signature: err, results\n */\n\n\nCursor.prototype._exec = function (_callback) {\n  var res = [],\n      added = 0,\n      skipped = 0,\n      self = this,\n      error = null,\n      i,\n      keys,\n      key;\n\n  function callback(error, res) {\n    if (self.execFn) {\n      return self.execFn(error, res, _callback);\n    } else {\n      return _callback(error, res);\n    }\n  }\n\n  this.db.getCandidates(this.query, function (err, candidates) {\n    if (err) {\n      return callback(err);\n    }\n\n    try {\n      for (i = 0; i < candidates.length; i += 1) {\n        if (model.match(candidates[i], self.query)) {\n          // If a sort is defined, wait for the results to be sorted before applying limit and skip\n          if (!self._sort) {\n            if (self._skip && self._skip > skipped) {\n              skipped += 1;\n            } else {\n              res.push(candidates[i]);\n              added += 1;\n\n              if (self._limit && self._limit <= added) {\n                break;\n              }\n            }\n          } else {\n            res.push(candidates[i]);\n          }\n        }\n      }\n    } catch (err) {\n      return callback(err);\n    } // Apply all sorts\n\n\n    if (self._sort) {\n      keys = Object.keys(self._sort); // Sorting\n\n      var criteria = [];\n\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n        criteria.push({\n          key: key,\n          direction: self._sort[key]\n        });\n      }\n\n      res.sort(function (a, b) {\n        var criterion, compare, i;\n\n        for (i = 0; i < criteria.length; i++) {\n          criterion = criteria[i];\n          compare = criterion.direction * model.compareThings(model.getDotValue(a, criterion.key), model.getDotValue(b, criterion.key), self.db.compareStrings);\n\n          if (compare !== 0) {\n            return compare;\n          }\n        }\n\n        return 0;\n      }); // Applying limit and skip\n\n      var limit = self._limit || res.length,\n          skip = self._skip || 0;\n      res = res.slice(skip, skip + limit);\n    } // Apply projection\n\n\n    try {\n      res = self.project(res);\n    } catch (e) {\n      error = e;\n      res = undefined;\n    }\n\n    return callback(error, res);\n  });\n};\n\nCursor.prototype.exec = function () {\n  this.db.executor.push({\n    this: this,\n    fn: this._exec,\n    arguments: arguments\n  });\n}; // Interface\n\n\nmodule.exports = Cursor;","map":null,"metadata":{},"sourceType":"script"}