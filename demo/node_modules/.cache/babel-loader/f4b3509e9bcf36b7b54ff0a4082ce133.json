{"ast":null,"code":"/**\n * Simple binary search tree\n */\nvar customUtils = require('./customUtils');\n/**\n * Constructor\n * @param {Object} options Optional\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Key}      options.key Initialize this BST's key with key\n * @param {Value}    options.value Initialize this BST's data with [value]\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\n\n\nfunction BinarySearchTree(options) {\n  options = options || {};\n  this.left = null;\n  this.right = null;\n  this.parent = options.parent !== undefined ? options.parent : null;\n\n  if (options.hasOwnProperty('key')) {\n    this.key = options.key;\n  }\n\n  this.data = options.hasOwnProperty('value') ? [options.value] : [];\n  this.unique = options.unique || false;\n  this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;\n  this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;\n} // ================================\n// Methods used to test the tree\n// ================================\n\n/**\n * Get the descendant with max key\n */\n\n\nBinarySearchTree.prototype.getMaxKeyDescendant = function () {\n  if (this.right) {\n    return this.right.getMaxKeyDescendant();\n  } else {\n    return this;\n  }\n};\n/**\n * Get the maximum key\n */\n\n\nBinarySearchTree.prototype.getMaxKey = function () {\n  return this.getMaxKeyDescendant().key;\n};\n/**\n * Get the descendant with min key\n */\n\n\nBinarySearchTree.prototype.getMinKeyDescendant = function () {\n  if (this.left) {\n    return this.left.getMinKeyDescendant();\n  } else {\n    return this;\n  }\n};\n/**\n * Get the minimum key\n */\n\n\nBinarySearchTree.prototype.getMinKey = function () {\n  return this.getMinKeyDescendant().key;\n};\n/**\n * Check that all nodes (incl. leaves) fullfil condition given by fn\n * test is a function passed every (key, data) and which throws if the condition is not met\n */\n\n\nBinarySearchTree.prototype.checkAllNodesFullfillCondition = function (test) {\n  if (!this.hasOwnProperty('key')) {\n    return;\n  }\n\n  test(this.key, this.data);\n\n  if (this.left) {\n    this.left.checkAllNodesFullfillCondition(test);\n  }\n\n  if (this.right) {\n    this.right.checkAllNodesFullfillCondition(test);\n  }\n};\n/**\n * Check that the core BST properties on node ordering are verified\n * Throw if they aren't\n */\n\n\nBinarySearchTree.prototype.checkNodeOrdering = function () {\n  var self = this;\n\n  if (!this.hasOwnProperty('key')) {\n    return;\n  }\n\n  if (this.left) {\n    this.left.checkAllNodesFullfillCondition(function (k) {\n      if (self.compareKeys(k, self.key) >= 0) {\n        throw new Error('Tree with root ' + self.key + ' is not a binary search tree');\n      }\n    });\n    this.left.checkNodeOrdering();\n  }\n\n  if (this.right) {\n    this.right.checkAllNodesFullfillCondition(function (k) {\n      if (self.compareKeys(k, self.key) <= 0) {\n        throw new Error('Tree with root ' + self.key + ' is not a binary search tree');\n      }\n    });\n    this.right.checkNodeOrdering();\n  }\n};\n/**\n * Check that all pointers are coherent in this tree\n */\n\n\nBinarySearchTree.prototype.checkInternalPointers = function () {\n  if (this.left) {\n    if (this.left.parent !== this) {\n      throw new Error('Parent pointer broken for key ' + this.key);\n    }\n\n    this.left.checkInternalPointers();\n  }\n\n  if (this.right) {\n    if (this.right.parent !== this) {\n      throw new Error('Parent pointer broken for key ' + this.key);\n    }\n\n    this.right.checkInternalPointers();\n  }\n};\n/**\n * Check that a tree is a BST as defined here (node ordering and pointer references)\n */\n\n\nBinarySearchTree.prototype.checkIsBST = function () {\n  this.checkNodeOrdering();\n  this.checkInternalPointers();\n\n  if (this.parent) {\n    throw new Error(\"The root shouldn't have a parent\");\n  }\n};\n/**\n * Get number of keys inserted\n */\n\n\nBinarySearchTree.prototype.getNumberOfKeys = function () {\n  var res;\n\n  if (!this.hasOwnProperty('key')) {\n    return 0;\n  }\n\n  res = 1;\n\n  if (this.left) {\n    res += this.left.getNumberOfKeys();\n  }\n\n  if (this.right) {\n    res += this.right.getNumberOfKeys();\n  }\n\n  return res;\n}; // ============================================\n// Methods used to actually work on the tree\n// ============================================\n\n/**\n * Create a BST similar (i.e. same options except for key and value) to the current one\n * Use the same constructor (i.e. BinarySearchTree, AVLTree etc)\n * @param {Object} options see constructor\n */\n\n\nBinarySearchTree.prototype.createSimilar = function (options) {\n  options = options || {};\n  options.unique = this.unique;\n  options.compareKeys = this.compareKeys;\n  options.checkValueEquality = this.checkValueEquality;\n  return new this.constructor(options);\n};\n/**\n * Create the left child of this BST and return it\n */\n\n\nBinarySearchTree.prototype.createLeftChild = function (options) {\n  var leftChild = this.createSimilar(options);\n  leftChild.parent = this;\n  this.left = leftChild;\n  return leftChild;\n};\n/**\n * Create the right child of this BST and return it\n */\n\n\nBinarySearchTree.prototype.createRightChild = function (options) {\n  var rightChild = this.createSimilar(options);\n  rightChild.parent = this;\n  this.right = rightChild;\n  return rightChild;\n};\n/**\n * Insert a new element\n */\n\n\nBinarySearchTree.prototype.insert = function (key, value) {\n  // Empty tree, insert as root\n  if (!this.hasOwnProperty('key')) {\n    this.key = key;\n    this.data.push(value);\n    return;\n  } // Same key as root\n\n\n  if (this.compareKeys(this.key, key) === 0) {\n    if (this.unique) {\n      var err = new Error(\"Can't insert key \" + key + \", it violates the unique constraint\");\n      err.key = key;\n      err.errorType = 'uniqueViolated';\n      throw err;\n    } else {\n      this.data.push(value);\n    }\n\n    return;\n  }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    // Insert in left subtree\n    if (this.left) {\n      this.left.insert(key, value);\n    } else {\n      this.createLeftChild({\n        key: key,\n        value: value\n      });\n    }\n  } else {\n    // Insert in right subtree\n    if (this.right) {\n      this.right.insert(key, value);\n    } else {\n      this.createRightChild({\n        key: key,\n        value: value\n      });\n    }\n  }\n};\n/**\n * Search for all data corresponding to a key\n */\n\n\nBinarySearchTree.prototype.search = function (key) {\n  if (!this.hasOwnProperty('key')) {\n    return [];\n  }\n\n  if (this.compareKeys(this.key, key) === 0) {\n    return this.data;\n  }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    if (this.left) {\n      return this.left.search(key);\n    } else {\n      return [];\n    }\n  } else {\n    if (this.right) {\n      return this.right.search(key);\n    } else {\n      return [];\n    }\n  }\n};\n/**\n * Return a function that tells whether a given key matches a lower bound\n */\n\n\nBinarySearchTree.prototype.getLowerBoundMatcher = function (query) {\n  var self = this; // No lower bound\n\n  if (!query.hasOwnProperty('$gt') && !query.hasOwnProperty('$gte')) {\n    return function () {\n      return true;\n    };\n  }\n\n  if (query.hasOwnProperty('$gt') && query.hasOwnProperty('$gte')) {\n    if (self.compareKeys(query.$gte, query.$gt) === 0) {\n      return function (key) {\n        return self.compareKeys(key, query.$gt) > 0;\n      };\n    }\n\n    if (self.compareKeys(query.$gte, query.$gt) > 0) {\n      return function (key) {\n        return self.compareKeys(key, query.$gte) >= 0;\n      };\n    } else {\n      return function (key) {\n        return self.compareKeys(key, query.$gt) > 0;\n      };\n    }\n  }\n\n  if (query.hasOwnProperty('$gt')) {\n    return function (key) {\n      return self.compareKeys(key, query.$gt) > 0;\n    };\n  } else {\n    return function (key) {\n      return self.compareKeys(key, query.$gte) >= 0;\n    };\n  }\n};\n/**\n * Return a function that tells whether a given key matches an upper bound\n */\n\n\nBinarySearchTree.prototype.getUpperBoundMatcher = function (query) {\n  var self = this; // No lower bound\n\n  if (!query.hasOwnProperty('$lt') && !query.hasOwnProperty('$lte')) {\n    return function () {\n      return true;\n    };\n  }\n\n  if (query.hasOwnProperty('$lt') && query.hasOwnProperty('$lte')) {\n    if (self.compareKeys(query.$lte, query.$lt) === 0) {\n      return function (key) {\n        return self.compareKeys(key, query.$lt) < 0;\n      };\n    }\n\n    if (self.compareKeys(query.$lte, query.$lt) < 0) {\n      return function (key) {\n        return self.compareKeys(key, query.$lte) <= 0;\n      };\n    } else {\n      return function (key) {\n        return self.compareKeys(key, query.$lt) < 0;\n      };\n    }\n  }\n\n  if (query.hasOwnProperty('$lt')) {\n    return function (key) {\n      return self.compareKeys(key, query.$lt) < 0;\n    };\n  } else {\n    return function (key) {\n      return self.compareKeys(key, query.$lte) <= 0;\n    };\n  }\n}; // Append all elements in toAppend to array\n\n\nfunction append(array, toAppend) {\n  var i;\n\n  for (i = 0; i < toAppend.length; i += 1) {\n    array.push(toAppend[i]);\n  }\n}\n/**\n * Get all data for a key between bounds\n * Return it in key order\n * @param {Object} query Mongo-style query where keys are $lt, $lte, $gt or $gte (other keys are not considered)\n * @param {Functions} lbm/ubm matching functions calculated at the first recursive step\n */\n\n\nBinarySearchTree.prototype.betweenBounds = function (query, lbm, ubm) {\n  var res = [];\n\n  if (!this.hasOwnProperty('key')) {\n    return [];\n  } // Empty tree\n\n\n  lbm = lbm || this.getLowerBoundMatcher(query);\n  ubm = ubm || this.getUpperBoundMatcher(query);\n\n  if (lbm(this.key) && this.left) {\n    append(res, this.left.betweenBounds(query, lbm, ubm));\n  }\n\n  if (lbm(this.key) && ubm(this.key)) {\n    append(res, this.data);\n  }\n\n  if (ubm(this.key) && this.right) {\n    append(res, this.right.betweenBounds(query, lbm, ubm));\n  }\n\n  return res;\n};\n/**\n * Delete the current node if it is a leaf\n * Return true if it was deleted\n */\n\n\nBinarySearchTree.prototype.deleteIfLeaf = function () {\n  if (this.left || this.right) {\n    return false;\n  } // The leaf is itself a root\n\n\n  if (!this.parent) {\n    delete this.key;\n    this.data = [];\n    return true;\n  }\n\n  if (this.parent.left === this) {\n    this.parent.left = null;\n  } else {\n    this.parent.right = null;\n  }\n\n  return true;\n};\n/**\n * Delete the current node if it has only one child\n * Return true if it was deleted\n */\n\n\nBinarySearchTree.prototype.deleteIfOnlyOneChild = function () {\n  var child;\n\n  if (this.left && !this.right) {\n    child = this.left;\n  }\n\n  if (!this.left && this.right) {\n    child = this.right;\n  }\n\n  if (!child) {\n    return false;\n  } // Root\n\n\n  if (!this.parent) {\n    this.key = child.key;\n    this.data = child.data;\n    this.left = null;\n\n    if (child.left) {\n      this.left = child.left;\n      child.left.parent = this;\n    }\n\n    this.right = null;\n\n    if (child.right) {\n      this.right = child.right;\n      child.right.parent = this;\n    }\n\n    return true;\n  }\n\n  if (this.parent.left === this) {\n    this.parent.left = child;\n    child.parent = this.parent;\n  } else {\n    this.parent.right = child;\n    child.parent = this.parent;\n  }\n\n  return true;\n};\n/**\n * Delete a key or just a value\n * @param {Key} key\n * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n */\n\n\nBinarySearchTree.prototype.delete = function (key, value) {\n  var newData = [],\n      replaceWith,\n      self = this;\n\n  if (!this.hasOwnProperty('key')) {\n    return;\n  }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    if (this.left) {\n      this.left.delete(key, value);\n    }\n\n    return;\n  }\n\n  if (this.compareKeys(key, this.key) > 0) {\n    if (this.right) {\n      this.right.delete(key, value);\n    }\n\n    return;\n  }\n\n  if (!this.compareKeys(key, this.key) === 0) {\n    return;\n  } // Delete only a value\n\n\n  if (this.data.length > 1 && value !== undefined) {\n    this.data.forEach(function (d) {\n      if (!self.checkValueEquality(d, value)) {\n        newData.push(d);\n      }\n    });\n    self.data = newData;\n    return;\n  } // Delete the whole node\n\n\n  if (this.deleteIfLeaf()) {\n    return;\n  }\n\n  if (this.deleteIfOnlyOneChild()) {\n    return;\n  } // We are in the case where the node to delete has two children\n\n\n  if (Math.random() >= 0.5) {\n    // Randomize replacement to avoid unbalancing the tree too much\n    // Use the in-order predecessor\n    replaceWith = this.left.getMaxKeyDescendant();\n    this.key = replaceWith.key;\n    this.data = replaceWith.data;\n\n    if (this === replaceWith.parent) {\n      // Special case\n      this.left = replaceWith.left;\n\n      if (replaceWith.left) {\n        replaceWith.left.parent = replaceWith.parent;\n      }\n    } else {\n      replaceWith.parent.right = replaceWith.left;\n\n      if (replaceWith.left) {\n        replaceWith.left.parent = replaceWith.parent;\n      }\n    }\n  } else {\n    // Use the in-order successor\n    replaceWith = this.right.getMinKeyDescendant();\n    this.key = replaceWith.key;\n    this.data = replaceWith.data;\n\n    if (this === replaceWith.parent) {\n      // Special case\n      this.right = replaceWith.right;\n\n      if (replaceWith.right) {\n        replaceWith.right.parent = replaceWith.parent;\n      }\n    } else {\n      replaceWith.parent.left = replaceWith.right;\n\n      if (replaceWith.right) {\n        replaceWith.right.parent = replaceWith.parent;\n      }\n    }\n  }\n};\n/**\n * Execute a function on every node of the tree, in key order\n * @param {Function} fn Signature: node. Most useful will probably be node.key and node.data\n */\n\n\nBinarySearchTree.prototype.executeOnEveryNode = function (fn) {\n  if (this.left) {\n    this.left.executeOnEveryNode(fn);\n  }\n\n  fn(this);\n\n  if (this.right) {\n    this.right.executeOnEveryNode(fn);\n  }\n};\n/**\n * Pretty print a tree\n * @param {Boolean} printData To print the nodes' data along with the key\n */\n\n\nBinarySearchTree.prototype.prettyPrint = function (printData, spacing) {\n  spacing = spacing || \"\";\n  console.log(spacing + \"* \" + this.key);\n\n  if (printData) {\n    console.log(spacing + \"* \" + this.data);\n  }\n\n  if (!this.left && !this.right) {\n    return;\n  }\n\n  if (this.left) {\n    this.left.prettyPrint(printData, spacing + \"  \");\n  } else {\n    console.log(spacing + \"  *\");\n  }\n\n  if (this.right) {\n    this.right.prettyPrint(printData, spacing + \"  \");\n  } else {\n    console.log(spacing + \"  *\");\n  }\n}; // Interface\n\n\nmodule.exports = BinarySearchTree;","map":null,"metadata":{},"sourceType":"script"}