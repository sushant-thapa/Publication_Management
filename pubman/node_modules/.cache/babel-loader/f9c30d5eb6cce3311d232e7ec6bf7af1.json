{"ast":null,"code":"/**\n * Handle every persistence-related task\n * The interface Datastore expects to be implemented is\n * * Persistence.loadDatabase(callback) and callback has signature err\n * * Persistence.persistNewState(newDocs, callback) where newDocs is an array of documents and callback has signature err\n */\nvar storage = require('./storage'),\n    path = require('path'),\n    model = require('./model'),\n    async = require('async'),\n    customUtils = require('./customUtils'),\n    Index = require('./indexes');\n/**\n * Create a new Persistence object for database options.db\n * @param {Datastore} options.db\n * @param {Boolean} options.nodeWebkitAppName Optional, specify the name of your NW app if you want options.filename to be relative to the directory where\n *                                            Node Webkit stores application data such as cookies and local storage (the best place to store data in my opinion)\n */\n\n\nfunction Persistence(options) {\n  var i, j, randomString;\n  this.db = options.db;\n  this.inMemoryOnly = this.db.inMemoryOnly;\n  this.filename = this.db.filename;\n  this.corruptAlertThreshold = options.corruptAlertThreshold !== undefined ? options.corruptAlertThreshold : 0.1;\n\n  if (!this.inMemoryOnly && this.filename && this.filename.charAt(this.filename.length - 1) === '~') {\n    throw new Error(\"The datafile name can't end with a ~, which is reserved for crash safe backup files\");\n  } // After serialization and before deserialization hooks with some basic sanity checks\n\n\n  if (options.afterSerialization && !options.beforeDeserialization) {\n    throw new Error(\"Serialization hook defined but deserialization hook undefined, cautiously refusing to start NeDB to prevent dataloss\");\n  }\n\n  if (!options.afterSerialization && options.beforeDeserialization) {\n    throw new Error(\"Serialization hook undefined but deserialization hook defined, cautiously refusing to start NeDB to prevent dataloss\");\n  }\n\n  this.afterSerialization = options.afterSerialization || function (s) {\n    return s;\n  };\n\n  this.beforeDeserialization = options.beforeDeserialization || function (s) {\n    return s;\n  };\n\n  for (i = 1; i < 30; i += 1) {\n    for (j = 0; j < 10; j += 1) {\n      randomString = customUtils.uid(i);\n\n      if (this.beforeDeserialization(this.afterSerialization(randomString)) !== randomString) {\n        throw new Error(\"beforeDeserialization is not the reverse of afterSerialization, cautiously refusing to start NeDB to prevent dataloss\");\n      }\n    }\n  } // For NW apps, store data in the same directory where NW stores application data\n\n\n  if (this.filename && options.nodeWebkitAppName) {\n    console.log(\"==================================================================\");\n    console.log(\"WARNING: The nodeWebkitAppName option is deprecated\");\n    console.log(\"To get the path to the directory where Node Webkit stores the data\");\n    console.log(\"for your app, use the internal nw.gui module like this\");\n    console.log(\"require('nw.gui').App.dataPath\");\n    console.log(\"See https://github.com/rogerwang/node-webkit/issues/500\");\n    console.log(\"==================================================================\");\n    this.filename = Persistence.getNWAppFilename(options.nodeWebkitAppName, this.filename);\n  }\n}\n\n;\n/**\n * Check if a directory exists and create it on the fly if it is not the case\n * cb is optional, signature: err\n */\n\nPersistence.ensureDirectoryExists = function (dir, cb) {\n  var callback = cb || function () {};\n\n  storage.mkdirp(dir, function (err) {\n    return callback(err);\n  });\n};\n/**\n * Return the path the datafile if the given filename is relative to the directory where Node Webkit stores\n * data for this application. Probably the best place to store data\n */\n\n\nPersistence.getNWAppFilename = function (appName, relativeFilename) {\n  var home;\n\n  switch (process.platform) {\n    case 'win32':\n    case 'win64':\n      home = process.env.LOCALAPPDATA || process.env.APPDATA;\n\n      if (!home) {\n        throw new Error(\"Couldn't find the base application data folder\");\n      }\n\n      home = path.join(home, appName);\n      break;\n\n    case 'darwin':\n      home = process.env.HOME;\n\n      if (!home) {\n        throw new Error(\"Couldn't find the base application data directory\");\n      }\n\n      home = path.join(home, 'Library', 'Application Support', appName);\n      break;\n\n    case 'linux':\n      home = process.env.HOME;\n\n      if (!home) {\n        throw new Error(\"Couldn't find the base application data directory\");\n      }\n\n      home = path.join(home, '.config', appName);\n      break;\n\n    default:\n      throw new Error(\"Can't use the Node Webkit relative path for platform \" + process.platform);\n      break;\n  }\n\n  return path.join(home, 'nedb-data', relativeFilename);\n};\n/**\n * Persist cached database\n * This serves as a compaction function since the cache always contains only the number of documents in the collection\n * while the data file is append-only so it may grow larger\n * @param {Function} cb Optional callback, signature: err\n */\n\n\nPersistence.prototype.persistCachedDatabase = function (cb) {\n  var callback = cb || function () {},\n      toPersist = '',\n      self = this;\n\n  if (this.inMemoryOnly) {\n    return callback(null);\n  }\n\n  this.db.getAllData().forEach(function (doc) {\n    toPersist += self.afterSerialization(model.serialize(doc)) + '\\n';\n  });\n  Object.keys(this.db.indexes).forEach(function (fieldName) {\n    if (fieldName != \"_id\") {\n      // The special _id index is managed by datastore.js, the others need to be persisted\n      toPersist += self.afterSerialization(model.serialize({\n        $$indexCreated: {\n          fieldName: fieldName,\n          unique: self.db.indexes[fieldName].unique,\n          sparse: self.db.indexes[fieldName].sparse\n        }\n      })) + '\\n';\n    }\n  });\n  storage.crashSafeWriteFile(this.filename, toPersist, function (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.db.emit('compaction.done');\n    return callback(null);\n  });\n};\n/**\n * Queue a rewrite of the datafile\n */\n\n\nPersistence.prototype.compactDatafile = function () {\n  this.db.executor.push({\n    this: this,\n    fn: this.persistCachedDatabase,\n    arguments: []\n  });\n};\n/**\n * Set automatic compaction every interval ms\n * @param {Number} interval in milliseconds, with an enforced minimum of 5 seconds\n */\n\n\nPersistence.prototype.setAutocompactionInterval = function (interval) {\n  var self = this,\n      minInterval = 5000,\n      realInterval = Math.max(interval || 0, minInterval);\n  this.stopAutocompaction();\n  this.autocompactionIntervalId = setInterval(function () {\n    self.compactDatafile();\n  }, realInterval);\n};\n/**\n * Stop autocompaction (do nothing if autocompaction was not running)\n */\n\n\nPersistence.prototype.stopAutocompaction = function () {\n  if (this.autocompactionIntervalId) {\n    clearInterval(this.autocompactionIntervalId);\n  }\n};\n/**\n * Persist new state for the given newDocs (can be insertion, update or removal)\n * Use an append-only format\n * @param {Array} newDocs Can be empty if no doc was updated/removed\n * @param {Function} cb Optional, signature: err\n */\n\n\nPersistence.prototype.persistNewState = function (newDocs, cb) {\n  var self = this,\n      toPersist = '',\n      callback = cb || function () {}; // In-memory only datastore\n\n\n  if (self.inMemoryOnly) {\n    return callback(null);\n  }\n\n  newDocs.forEach(function (doc) {\n    toPersist += self.afterSerialization(model.serialize(doc)) + '\\n';\n  });\n\n  if (toPersist.length === 0) {\n    return callback(null);\n  }\n\n  storage.appendFile(self.filename, toPersist, 'utf8', function (err) {\n    return callback(err);\n  });\n};\n/**\n * From a database's raw data, return the corresponding\n * machine understandable collection\n */\n\n\nPersistence.prototype.treatRawData = function (rawData) {\n  var data = rawData.split('\\n'),\n      dataById = {},\n      tdata = [],\n      i,\n      indexes = {},\n      corruptItems = -1 // Last line of every data file is usually blank so not really corrupt\n  ;\n\n  for (i = 0; i < data.length; i += 1) {\n    var doc;\n\n    try {\n      doc = model.deserialize(this.beforeDeserialization(data[i]));\n\n      if (doc._id) {\n        if (doc.$$deleted === true) {\n          delete dataById[doc._id];\n        } else {\n          dataById[doc._id] = doc;\n        }\n      } else if (doc.$$indexCreated && doc.$$indexCreated.fieldName != undefined) {\n        indexes[doc.$$indexCreated.fieldName] = doc.$$indexCreated;\n      } else if (typeof doc.$$indexRemoved === \"string\") {\n        delete indexes[doc.$$indexRemoved];\n      }\n    } catch (e) {\n      corruptItems += 1;\n    }\n  } // A bit lenient on corruption\n\n\n  if (data.length > 0 && corruptItems / data.length > this.corruptAlertThreshold) {\n    throw new Error(\"More than \" + Math.floor(100 * this.corruptAlertThreshold) + \"% of the data file is corrupt, the wrong beforeDeserialization hook may be used. Cautiously refusing to start NeDB to prevent dataloss\");\n  }\n\n  Object.keys(dataById).forEach(function (k) {\n    tdata.push(dataById[k]);\n  });\n  return {\n    data: tdata,\n    indexes: indexes\n  };\n};\n/**\n * Load the database\n * 1) Create all indexes\n * 2) Insert all data\n * 3) Compact the database\n * This means pulling data out of the data file or creating it if it doesn't exist\n * Also, all data is persisted right away, which has the effect of compacting the database file\n * This operation is very quick at startup for a big collection (60ms for ~10k docs)\n * @param {Function} cb Optional callback, signature: err\n */\n\n\nPersistence.prototype.loadDatabase = function (cb) {\n  var callback = cb || function () {},\n      self = this;\n\n  self.db.resetIndexes(); // In-memory only datastore\n\n  if (self.inMemoryOnly) {\n    return callback(null);\n  }\n\n  async.waterfall([function (cb) {\n    Persistence.ensureDirectoryExists(path.dirname(self.filename), function (err) {\n      storage.ensureDatafileIntegrity(self.filename, function (err) {\n        storage.readFile(self.filename, 'utf8', function (err, rawData) {\n          if (err) {\n            return cb(err);\n          }\n\n          try {\n            var treatedData = self.treatRawData(rawData);\n          } catch (e) {\n            return cb(e);\n          } // Recreate all indexes in the datafile\n\n\n          Object.keys(treatedData.indexes).forEach(function (key) {\n            self.db.indexes[key] = new Index(treatedData.indexes[key]);\n          }); // Fill cached database (i.e. all indexes) with data\n\n          try {\n            self.db.resetIndexes(treatedData.data);\n          } catch (e) {\n            self.db.resetIndexes(); // Rollback any index which didn't fail\n\n            return cb(e);\n          }\n\n          self.db.persistence.persistCachedDatabase(cb);\n        });\n      });\n    });\n  }], function (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.db.executor.processBuffer();\n    return callback(null);\n  });\n}; // Interface\n\n\nmodule.exports = Persistence;","map":null,"metadata":{},"sourceType":"script"}