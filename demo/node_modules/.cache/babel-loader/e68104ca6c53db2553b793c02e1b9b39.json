{"ast":null,"code":"var BinarySearchTree = require('binary-search-tree').AVLTree,\n    model = require('./model'),\n    _ = require('underscore'),\n    util = require('util');\n/**\n * Two indexed pointers are equal iif they point to the same place\n */\n\n\nfunction checkValueEquality(a, b) {\n  return a === b;\n}\n/**\n * Type-aware projection\n */\n\n\nfunction projectForUnique(elt) {\n  if (elt === null) {\n    return '$null';\n  }\n\n  if (typeof elt === 'string') {\n    return '$string' + elt;\n  }\n\n  if (typeof elt === 'boolean') {\n    return '$boolean' + elt;\n  }\n\n  if (typeof elt === 'number') {\n    return '$number' + elt;\n  }\n\n  if (util.isArray(elt)) {\n    return '$date' + elt.getTime();\n  }\n\n  return elt; // Arrays and objects, will check for pointer equality\n}\n/**\n * Create a new index\n * All methods on an index guarantee that either the whole operation was successful and the index changed\n * or the operation was unsuccessful and an error is thrown while the index is unchanged\n * @param {String} options.fieldName On which field should the index apply (can use dot notation to index on sub fields)\n * @param {Boolean} options.unique Optional, enforce a unique constraint (default: false)\n * @param {Boolean} options.sparse Optional, allow a sparse index (we can have documents for which fieldName is undefined) (default: false)\n */\n\n\nfunction Index(options) {\n  this.fieldName = options.fieldName;\n  this.unique = options.unique || false;\n  this.sparse = options.sparse || false;\n  this.treeOptions = {\n    unique: this.unique,\n    compareKeys: model.compareThings,\n    checkValueEquality: checkValueEquality\n  };\n  this.reset(); // No data in the beginning\n}\n/**\n * Reset an index\n * @param {Document or Array of documents} newData Optional, data to initialize the index with\n *                                                 If an error is thrown during insertion, the index is not modified\n */\n\n\nIndex.prototype.reset = function (newData) {\n  this.tree = new BinarySearchTree(this.treeOptions);\n\n  if (newData) {\n    this.insert(newData);\n  }\n};\n/**\n * Insert a new document in the index\n * If an array is passed, we insert all its elements (if one insertion fails the index is not modified)\n * O(log(n))\n */\n\n\nIndex.prototype.insert = function (doc) {\n  var key,\n      self = this,\n      keys,\n      i,\n      failingI,\n      error;\n\n  if (util.isArray(doc)) {\n    this.insertMultipleDocs(doc);\n    return;\n  }\n\n  key = model.getDotValue(doc, this.fieldName); // We don't index documents that don't contain the field if the index is sparse\n\n  if (key === undefined && this.sparse) {\n    return;\n  }\n\n  if (!util.isArray(key)) {\n    this.tree.insert(key, doc);\n  } else {\n    // If an insert fails due to a unique constraint, roll back all inserts before it\n    keys = _.uniq(key, projectForUnique);\n\n    for (i = 0; i < keys.length; i += 1) {\n      try {\n        this.tree.insert(keys[i], doc);\n      } catch (e) {\n        error = e;\n        failingI = i;\n        break;\n      }\n    }\n\n    if (error) {\n      for (i = 0; i < failingI; i += 1) {\n        this.tree.delete(keys[i], doc);\n      }\n\n      throw error;\n    }\n  }\n};\n/**\n * Insert an array of documents in the index\n * If a constraint is violated, the changes should be rolled back and an error thrown\n *\n * @API private\n */\n\n\nIndex.prototype.insertMultipleDocs = function (docs) {\n  var i, error, failingI;\n\n  for (i = 0; i < docs.length; i += 1) {\n    try {\n      this.insert(docs[i]);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  }\n\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.remove(docs[i]);\n    }\n\n    throw error;\n  }\n};\n/**\n * Remove a document from the index\n * If an array is passed, we remove all its elements\n * The remove operation is safe with regards to the 'unique' constraint\n * O(log(n))\n */\n\n\nIndex.prototype.remove = function (doc) {\n  var key,\n      self = this;\n\n  if (util.isArray(doc)) {\n    doc.forEach(function (d) {\n      self.remove(d);\n    });\n    return;\n  }\n\n  key = model.getDotValue(doc, this.fieldName);\n\n  if (key === undefined && this.sparse) {\n    return;\n  }\n\n  if (!util.isArray(key)) {\n    this.tree.delete(key, doc);\n  } else {\n    _.uniq(key, projectForUnique).forEach(function (_key) {\n      self.tree.delete(_key, doc);\n    });\n  }\n};\n/**\n * Update a document in the index\n * If a constraint is violated, changes are rolled back and an error thrown\n * Naive implementation, still in O(log(n))\n */\n\n\nIndex.prototype.update = function (oldDoc, newDoc) {\n  if (util.isArray(oldDoc)) {\n    this.updateMultipleDocs(oldDoc);\n    return;\n  }\n\n  this.remove(oldDoc);\n\n  try {\n    this.insert(newDoc);\n  } catch (e) {\n    this.insert(oldDoc);\n    throw e;\n  }\n};\n/**\n * Update multiple documents in the index\n * If a constraint is violated, the changes need to be rolled back\n * and an error thrown\n * @param {Array of oldDoc, newDoc pairs} pairs\n *\n * @API private\n */\n\n\nIndex.prototype.updateMultipleDocs = function (pairs) {\n  var i, failingI, error;\n\n  for (i = 0; i < pairs.length; i += 1) {\n    this.remove(pairs[i].oldDoc);\n  }\n\n  for (i = 0; i < pairs.length; i += 1) {\n    try {\n      this.insert(pairs[i].newDoc);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  } // If an error was raised, roll back changes in the inverse order\n\n\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.remove(pairs[i].newDoc);\n    }\n\n    for (i = 0; i < pairs.length; i += 1) {\n      this.insert(pairs[i].oldDoc);\n    }\n\n    throw error;\n  }\n};\n/**\n * Revert an update\n */\n\n\nIndex.prototype.revertUpdate = function (oldDoc, newDoc) {\n  var revert = [];\n\n  if (!util.isArray(oldDoc)) {\n    this.update(newDoc, oldDoc);\n  } else {\n    oldDoc.forEach(function (pair) {\n      revert.push({\n        oldDoc: pair.newDoc,\n        newDoc: pair.oldDoc\n      });\n    });\n    this.update(revert);\n  }\n};\n/**\n * Get all documents in index whose key match value (if it is a Thing) or one of the elements of value (if it is an array of Things)\n * @param {Thing} value Value to match the key against\n * @return {Array of documents}\n */\n\n\nIndex.prototype.getMatching = function (value) {\n  var self = this;\n\n  if (!util.isArray(value)) {\n    return self.tree.search(value);\n  } else {\n    var _res = {},\n        res = [];\n    value.forEach(function (v) {\n      self.getMatching(v).forEach(function (doc) {\n        _res[doc._id] = doc;\n      });\n    });\n    Object.keys(_res).forEach(function (_id) {\n      res.push(_res[_id]);\n    });\n    return res;\n  }\n};\n/**\n * Get all documents in index whose key is between bounds are they are defined by query\n * Documents are sorted by key\n * @param {Query} query\n * @return {Array of documents}\n */\n\n\nIndex.prototype.getBetweenBounds = function (query) {\n  return this.tree.betweenBounds(query);\n};\n/**\n * Get all elements in the index\n * @return {Array of documents}\n */\n\n\nIndex.prototype.getAll = function () {\n  var res = [];\n  this.tree.executeOnEveryNode(function (node) {\n    var i;\n\n    for (i = 0; i < node.data.length; i += 1) {\n      res.push(node.data[i]);\n    }\n  });\n  return res;\n}; // Interface\n\n\nmodule.exports = Index;","map":null,"metadata":{},"sourceType":"script"}