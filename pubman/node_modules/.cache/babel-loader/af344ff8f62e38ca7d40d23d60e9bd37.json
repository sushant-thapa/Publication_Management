{"ast":null,"code":"/*global setImmediate: false, setTimeout: false, console: false */\n(function () {\n  var async = {}; // global on the server, window in the browser\n\n  var root, previous_async;\n  root = this;\n\n  if (root != null) {\n    previous_async = root.async;\n  }\n\n  async.noConflict = function () {\n    root.async = previous_async;\n    return async;\n  };\n\n  function only_once(fn) {\n    var called = false;\n    return function () {\n      if (called) throw new Error(\"Callback was already called.\");\n      called = true;\n      fn.apply(root, arguments);\n    };\n  } //// cross-browser compatiblity functions ////\n\n\n  var _each = function _each(arr, iterator) {\n    if (arr.forEach) {\n      return arr.forEach(iterator);\n    }\n\n    for (var i = 0; i < arr.length; i += 1) {\n      iterator(arr[i], i, arr);\n    }\n  };\n\n  var _map = function _map(arr, iterator) {\n    if (arr.map) {\n      return arr.map(iterator);\n    }\n\n    var results = [];\n\n    _each(arr, function (x, i, a) {\n      results.push(iterator(x, i, a));\n    });\n\n    return results;\n  };\n\n  var _reduce = function _reduce(arr, iterator, memo) {\n    if (arr.reduce) {\n      return arr.reduce(iterator, memo);\n    }\n\n    _each(arr, function (x, i, a) {\n      memo = iterator(memo, x, i, a);\n    });\n\n    return memo;\n  };\n\n  var _keys = function _keys(obj) {\n    if (Object.keys) {\n      return Object.keys(obj);\n    }\n\n    var keys = [];\n\n    for (var k in obj) {\n      if (obj.hasOwnProperty(k)) {\n        keys.push(k);\n      }\n    }\n\n    return keys;\n  }; //// exported async module functions ////\n  //// nextTick implementation with browser-compatible fallback ////\n\n\n  if (typeof process === 'undefined' || !process.nextTick) {\n    if (typeof setImmediate === 'function') {\n      async.nextTick = function (fn) {\n        // not a direct alias for IE10 compatibility\n        setImmediate(fn);\n      };\n\n      async.setImmediate = async.nextTick;\n    } else {\n      async.nextTick = function (fn) {\n        setTimeout(fn, 0);\n      };\n\n      async.setImmediate = async.nextTick;\n    }\n  } else {\n    async.nextTick = process.nextTick;\n\n    if (typeof setImmediate !== 'undefined') {\n      async.setImmediate = function (fn) {\n        // not a direct alias for IE10 compatibility\n        setImmediate(fn);\n      };\n    } else {\n      async.setImmediate = async.nextTick;\n    }\n  }\n\n  async.each = function (arr, iterator, callback) {\n    callback = callback || function () {};\n\n    if (!arr.length) {\n      return callback();\n    }\n\n    var completed = 0;\n\n    _each(arr, function (x) {\n      iterator(x, only_once(function (err) {\n        if (err) {\n          callback(err);\n\n          callback = function callback() {};\n        } else {\n          completed += 1;\n\n          if (completed >= arr.length) {\n            callback(null);\n          }\n        }\n      }));\n    });\n  };\n\n  async.forEach = async.each;\n\n  async.eachSeries = function (arr, iterator, callback) {\n    callback = callback || function () {};\n\n    if (!arr.length) {\n      return callback();\n    }\n\n    var completed = 0;\n\n    var iterate = function iterate() {\n      iterator(arr[completed], function (err) {\n        if (err) {\n          callback(err);\n\n          callback = function callback() {};\n        } else {\n          completed += 1;\n\n          if (completed >= arr.length) {\n            callback(null);\n          } else {\n            iterate();\n          }\n        }\n      });\n    };\n\n    iterate();\n  };\n\n  async.forEachSeries = async.eachSeries;\n\n  async.eachLimit = function (arr, limit, iterator, callback) {\n    var fn = _eachLimit(limit);\n\n    fn.apply(null, [arr, iterator, callback]);\n  };\n\n  async.forEachLimit = async.eachLimit;\n\n  var _eachLimit = function _eachLimit(limit) {\n    return function (arr, iterator, callback) {\n      callback = callback || function () {};\n\n      if (!arr.length || limit <= 0) {\n        return callback();\n      }\n\n      var completed = 0;\n      var started = 0;\n      var running = 0;\n\n      (function replenish() {\n        if (completed >= arr.length) {\n          return callback();\n        }\n\n        while (running < limit && started < arr.length) {\n          started += 1;\n          running += 1;\n          iterator(arr[started - 1], function (err) {\n            if (err) {\n              callback(err);\n\n              callback = function callback() {};\n            } else {\n              completed += 1;\n              running -= 1;\n\n              if (completed >= arr.length) {\n                callback();\n              } else {\n                replenish();\n              }\n            }\n          });\n        }\n      })();\n    };\n  };\n\n  var doParallel = function doParallel(fn) {\n    return function () {\n      var args = Array.prototype.slice.call(arguments);\n      return fn.apply(null, [async.each].concat(args));\n    };\n  };\n\n  var doParallelLimit = function doParallelLimit(limit, fn) {\n    return function () {\n      var args = Array.prototype.slice.call(arguments);\n      return fn.apply(null, [_eachLimit(limit)].concat(args));\n    };\n  };\n\n  var doSeries = function doSeries(fn) {\n    return function () {\n      var args = Array.prototype.slice.call(arguments);\n      return fn.apply(null, [async.eachSeries].concat(args));\n    };\n  };\n\n  var _asyncMap = function _asyncMap(eachfn, arr, iterator, callback) {\n    var results = [];\n    arr = _map(arr, function (x, i) {\n      return {\n        index: i,\n        value: x\n      };\n    });\n    eachfn(arr, function (x, callback) {\n      iterator(x.value, function (err, v) {\n        results[x.index] = v;\n        callback(err);\n      });\n    }, function (err) {\n      callback(err, results);\n    });\n  };\n\n  async.map = doParallel(_asyncMap);\n  async.mapSeries = doSeries(_asyncMap);\n\n  async.mapLimit = function (arr, limit, iterator, callback) {\n    return _mapLimit(limit)(arr, iterator, callback);\n  };\n\n  var _mapLimit = function _mapLimit(limit) {\n    return doParallelLimit(limit, _asyncMap);\n  }; // reduce only has a series version, as doing reduce in parallel won't\n  // work in many situations.\n\n\n  async.reduce = function (arr, memo, iterator, callback) {\n    async.eachSeries(arr, function (x, callback) {\n      iterator(memo, x, function (err, v) {\n        memo = v;\n        callback(err);\n      });\n    }, function (err) {\n      callback(err, memo);\n    });\n  }; // inject alias\n\n\n  async.inject = async.reduce; // foldl alias\n\n  async.foldl = async.reduce;\n\n  async.reduceRight = function (arr, memo, iterator, callback) {\n    var reversed = _map(arr, function (x) {\n      return x;\n    }).reverse();\n\n    async.reduce(reversed, memo, iterator, callback);\n  }; // foldr alias\n\n\n  async.foldr = async.reduceRight;\n\n  var _filter = function _filter(eachfn, arr, iterator, callback) {\n    var results = [];\n    arr = _map(arr, function (x, i) {\n      return {\n        index: i,\n        value: x\n      };\n    });\n    eachfn(arr, function (x, callback) {\n      iterator(x.value, function (v) {\n        if (v) {\n          results.push(x);\n        }\n\n        callback();\n      });\n    }, function (err) {\n      callback(_map(results.sort(function (a, b) {\n        return a.index - b.index;\n      }), function (x) {\n        return x.value;\n      }));\n    });\n  };\n\n  async.filter = doParallel(_filter);\n  async.filterSeries = doSeries(_filter); // select alias\n\n  async.select = async.filter;\n  async.selectSeries = async.filterSeries;\n\n  var _reject = function _reject(eachfn, arr, iterator, callback) {\n    var results = [];\n    arr = _map(arr, function (x, i) {\n      return {\n        index: i,\n        value: x\n      };\n    });\n    eachfn(arr, function (x, callback) {\n      iterator(x.value, function (v) {\n        if (!v) {\n          results.push(x);\n        }\n\n        callback();\n      });\n    }, function (err) {\n      callback(_map(results.sort(function (a, b) {\n        return a.index - b.index;\n      }), function (x) {\n        return x.value;\n      }));\n    });\n  };\n\n  async.reject = doParallel(_reject);\n  async.rejectSeries = doSeries(_reject);\n\n  var _detect = function _detect(eachfn, arr, iterator, main_callback) {\n    eachfn(arr, function (x, callback) {\n      iterator(x, function (result) {\n        if (result) {\n          main_callback(x);\n\n          main_callback = function main_callback() {};\n        } else {\n          callback();\n        }\n      });\n    }, function (err) {\n      main_callback();\n    });\n  };\n\n  async.detect = doParallel(_detect);\n  async.detectSeries = doSeries(_detect);\n\n  async.some = function (arr, iterator, main_callback) {\n    async.each(arr, function (x, callback) {\n      iterator(x, function (v) {\n        if (v) {\n          main_callback(true);\n\n          main_callback = function main_callback() {};\n        }\n\n        callback();\n      });\n    }, function (err) {\n      main_callback(false);\n    });\n  }; // any alias\n\n\n  async.any = async.some;\n\n  async.every = function (arr, iterator, main_callback) {\n    async.each(arr, function (x, callback) {\n      iterator(x, function (v) {\n        if (!v) {\n          main_callback(false);\n\n          main_callback = function main_callback() {};\n        }\n\n        callback();\n      });\n    }, function (err) {\n      main_callback(true);\n    });\n  }; // all alias\n\n\n  async.all = async.every;\n\n  async.sortBy = function (arr, iterator, callback) {\n    async.map(arr, function (x, callback) {\n      iterator(x, function (err, criteria) {\n        if (err) {\n          callback(err);\n        } else {\n          callback(null, {\n            value: x,\n            criteria: criteria\n          });\n        }\n      });\n    }, function (err, results) {\n      if (err) {\n        return callback(err);\n      } else {\n        var fn = function fn(left, right) {\n          var a = left.criteria,\n              b = right.criteria;\n          return a < b ? -1 : a > b ? 1 : 0;\n        };\n\n        callback(null, _map(results.sort(fn), function (x) {\n          return x.value;\n        }));\n      }\n    });\n  };\n\n  async.auto = function (tasks, callback) {\n    callback = callback || function () {};\n\n    var keys = _keys(tasks);\n\n    if (!keys.length) {\n      return callback(null);\n    }\n\n    var results = {};\n    var listeners = [];\n\n    var addListener = function addListener(fn) {\n      listeners.unshift(fn);\n    };\n\n    var removeListener = function removeListener(fn) {\n      for (var i = 0; i < listeners.length; i += 1) {\n        if (listeners[i] === fn) {\n          listeners.splice(i, 1);\n          return;\n        }\n      }\n    };\n\n    var taskComplete = function taskComplete() {\n      _each(listeners.slice(0), function (fn) {\n        fn();\n      });\n    };\n\n    addListener(function () {\n      if (_keys(results).length === keys.length) {\n        callback(null, results);\n\n        callback = function callback() {};\n      }\n    });\n\n    _each(keys, function (k) {\n      var task = tasks[k] instanceof Function ? [tasks[k]] : tasks[k];\n\n      var taskCallback = function taskCallback(err) {\n        var args = Array.prototype.slice.call(arguments, 1);\n\n        if (args.length <= 1) {\n          args = args[0];\n        }\n\n        if (err) {\n          var safeResults = {};\n\n          _each(_keys(results), function (rkey) {\n            safeResults[rkey] = results[rkey];\n          });\n\n          safeResults[k] = args;\n          callback(err, safeResults); // stop subsequent errors hitting callback multiple times\n\n          callback = function callback() {};\n        } else {\n          results[k] = args;\n          async.setImmediate(taskComplete);\n        }\n      };\n\n      var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n\n      var ready = function ready() {\n        return _reduce(requires, function (a, x) {\n          return a && results.hasOwnProperty(x);\n        }, true) && !results.hasOwnProperty(k);\n      };\n\n      if (ready()) {\n        task[task.length - 1](taskCallback, results);\n      } else {\n        var listener = function listener() {\n          if (ready()) {\n            removeListener(listener);\n            task[task.length - 1](taskCallback, results);\n          }\n        };\n\n        addListener(listener);\n      }\n    });\n  };\n\n  async.waterfall = function (tasks, callback) {\n    callback = callback || function () {};\n\n    if (tasks.constructor !== Array) {\n      var err = new Error('First argument to waterfall must be an array of functions');\n      return callback(err);\n    }\n\n    if (!tasks.length) {\n      return callback();\n    }\n\n    var wrapIterator = function wrapIterator(iterator) {\n      return function (err) {\n        if (err) {\n          callback.apply(null, arguments);\n\n          callback = function callback() {};\n        } else {\n          var args = Array.prototype.slice.call(arguments, 1);\n          var next = iterator.next();\n\n          if (next) {\n            args.push(wrapIterator(next));\n          } else {\n            args.push(callback);\n          }\n\n          async.setImmediate(function () {\n            iterator.apply(null, args);\n          });\n        }\n      };\n    };\n\n    wrapIterator(async.iterator(tasks))();\n  };\n\n  var _parallel = function _parallel(eachfn, tasks, callback) {\n    callback = callback || function () {};\n\n    if (tasks.constructor === Array) {\n      eachfn.map(tasks, function (fn, callback) {\n        if (fn) {\n          fn(function (err) {\n            var args = Array.prototype.slice.call(arguments, 1);\n\n            if (args.length <= 1) {\n              args = args[0];\n            }\n\n            callback.call(null, err, args);\n          });\n        }\n      }, callback);\n    } else {\n      var results = {};\n      eachfn.each(_keys(tasks), function (k, callback) {\n        tasks[k](function (err) {\n          var args = Array.prototype.slice.call(arguments, 1);\n\n          if (args.length <= 1) {\n            args = args[0];\n          }\n\n          results[k] = args;\n          callback(err);\n        });\n      }, function (err) {\n        callback(err, results);\n      });\n    }\n  };\n\n  async.parallel = function (tasks, callback) {\n    _parallel({\n      map: async.map,\n      each: async.each\n    }, tasks, callback);\n  };\n\n  async.parallelLimit = function (tasks, limit, callback) {\n    _parallel({\n      map: _mapLimit(limit),\n      each: _eachLimit(limit)\n    }, tasks, callback);\n  };\n\n  async.series = function (tasks, callback) {\n    callback = callback || function () {};\n\n    if (tasks.constructor === Array) {\n      async.mapSeries(tasks, function (fn, callback) {\n        if (fn) {\n          fn(function (err) {\n            var args = Array.prototype.slice.call(arguments, 1);\n\n            if (args.length <= 1) {\n              args = args[0];\n            }\n\n            callback.call(null, err, args);\n          });\n        }\n      }, callback);\n    } else {\n      var results = {};\n      async.eachSeries(_keys(tasks), function (k, callback) {\n        tasks[k](function (err) {\n          var args = Array.prototype.slice.call(arguments, 1);\n\n          if (args.length <= 1) {\n            args = args[0];\n          }\n\n          results[k] = args;\n          callback(err);\n        });\n      }, function (err) {\n        callback(err, results);\n      });\n    }\n  };\n\n  async.iterator = function (tasks) {\n    var makeCallback = function makeCallback(index) {\n      var fn = function fn() {\n        if (tasks.length) {\n          tasks[index].apply(null, arguments);\n        }\n\n        return fn.next();\n      };\n\n      fn.next = function () {\n        return index < tasks.length - 1 ? makeCallback(index + 1) : null;\n      };\n\n      return fn;\n    };\n\n    return makeCallback(0);\n  };\n\n  async.apply = function (fn) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function () {\n      return fn.apply(null, args.concat(Array.prototype.slice.call(arguments)));\n    };\n  };\n\n  var _concat = function _concat(eachfn, arr, fn, callback) {\n    var r = [];\n    eachfn(arr, function (x, cb) {\n      fn(x, function (err, y) {\n        r = r.concat(y || []);\n        cb(err);\n      });\n    }, function (err) {\n      callback(err, r);\n    });\n  };\n\n  async.concat = doParallel(_concat);\n  async.concatSeries = doSeries(_concat);\n\n  async.whilst = function (test, iterator, callback) {\n    if (test()) {\n      iterator(function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        async.whilst(test, iterator, callback);\n      });\n    } else {\n      callback();\n    }\n  };\n\n  async.doWhilst = function (iterator, test, callback) {\n    iterator(function (err) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (test()) {\n        async.doWhilst(iterator, test, callback);\n      } else {\n        callback();\n      }\n    });\n  };\n\n  async.until = function (test, iterator, callback) {\n    if (!test()) {\n      iterator(function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        async.until(test, iterator, callback);\n      });\n    } else {\n      callback();\n    }\n  };\n\n  async.doUntil = function (iterator, test, callback) {\n    iterator(function (err) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (!test()) {\n        async.doUntil(iterator, test, callback);\n      } else {\n        callback();\n      }\n    });\n  };\n\n  async.queue = function (worker, concurrency) {\n    if (concurrency === undefined) {\n      concurrency = 1;\n    }\n\n    function _insert(q, data, pos, callback) {\n      if (data.constructor !== Array) {\n        data = [data];\n      }\n\n      _each(data, function (task) {\n        var item = {\n          data: task,\n          callback: typeof callback === 'function' ? callback : null\n        };\n\n        if (pos) {\n          q.tasks.unshift(item);\n        } else {\n          q.tasks.push(item);\n        }\n\n        if (q.saturated && q.tasks.length === concurrency) {\n          q.saturated();\n        }\n\n        async.setImmediate(q.process);\n      });\n    }\n\n    var workers = 0;\n    var q = {\n      tasks: [],\n      concurrency: concurrency,\n      saturated: null,\n      empty: null,\n      drain: null,\n      push: function push(data, callback) {\n        _insert(q, data, false, callback);\n      },\n      unshift: function unshift(data, callback) {\n        _insert(q, data, true, callback);\n      },\n      process: function process() {\n        if (workers < q.concurrency && q.tasks.length) {\n          var task = q.tasks.shift();\n\n          if (q.empty && q.tasks.length === 0) {\n            q.empty();\n          }\n\n          workers += 1;\n\n          var next = function next() {\n            workers -= 1;\n\n            if (task.callback) {\n              task.callback.apply(task, arguments);\n            }\n\n            if (q.drain && q.tasks.length + workers === 0) {\n              q.drain();\n            }\n\n            q.process();\n          };\n\n          var cb = only_once(next);\n          worker(task.data, cb);\n        }\n      },\n      length: function length() {\n        return q.tasks.length;\n      },\n      running: function running() {\n        return workers;\n      }\n    };\n    return q;\n  };\n\n  async.cargo = function (worker, payload) {\n    var working = false,\n        tasks = [];\n    var cargo = {\n      tasks: tasks,\n      payload: payload,\n      saturated: null,\n      empty: null,\n      drain: null,\n      push: function push(data, callback) {\n        if (data.constructor !== Array) {\n          data = [data];\n        }\n\n        _each(data, function (task) {\n          tasks.push({\n            data: task,\n            callback: typeof callback === 'function' ? callback : null\n          });\n\n          if (cargo.saturated && tasks.length === payload) {\n            cargo.saturated();\n          }\n        });\n\n        async.setImmediate(cargo.process);\n      },\n      process: function process() {\n        if (working) return;\n\n        if (tasks.length === 0) {\n          if (cargo.drain) cargo.drain();\n          return;\n        }\n\n        var ts = typeof payload === 'number' ? tasks.splice(0, payload) : tasks.splice(0);\n\n        var ds = _map(ts, function (task) {\n          return task.data;\n        });\n\n        if (cargo.empty) cargo.empty();\n        working = true;\n        worker(ds, function () {\n          working = false;\n          var args = arguments;\n\n          _each(ts, function (data) {\n            if (data.callback) {\n              data.callback.apply(null, args);\n            }\n          });\n\n          process();\n        });\n      },\n      length: function length() {\n        return tasks.length;\n      },\n      running: function running() {\n        return working;\n      }\n    };\n    return cargo;\n  };\n\n  var _console_fn = function _console_fn(name) {\n    return function (fn) {\n      var args = Array.prototype.slice.call(arguments, 1);\n      fn.apply(null, args.concat([function (err) {\n        var args = Array.prototype.slice.call(arguments, 1);\n\n        if (typeof console !== 'undefined') {\n          if (err) {\n            if (console.error) {\n              console.error(err);\n            }\n          } else if (console[name]) {\n            _each(args, function (x) {\n              console[name](x);\n            });\n          }\n        }\n      }]));\n    };\n  };\n\n  async.log = _console_fn('log');\n  async.dir = _console_fn('dir');\n  /*async.info = _console_fn('info');\n  async.warn = _console_fn('warn');\n  async.error = _console_fn('error');*/\n\n  async.memoize = function (fn, hasher) {\n    var memo = {};\n    var queues = {};\n\n    hasher = hasher || function (x) {\n      return x;\n    };\n\n    var memoized = function memoized() {\n      var args = Array.prototype.slice.call(arguments);\n      var callback = args.pop();\n      var key = hasher.apply(null, args);\n\n      if (key in memo) {\n        callback.apply(null, memo[key]);\n      } else if (key in queues) {\n        queues[key].push(callback);\n      } else {\n        queues[key] = [callback];\n        fn.apply(null, args.concat([function () {\n          memo[key] = arguments;\n          var q = queues[key];\n          delete queues[key];\n\n          for (var i = 0, l = q.length; i < l; i++) {\n            q[i].apply(null, arguments);\n          }\n        }]));\n      }\n    };\n\n    memoized.memo = memo;\n    memoized.unmemoized = fn;\n    return memoized;\n  };\n\n  async.unmemoize = function (fn) {\n    return function () {\n      return (fn.unmemoized || fn).apply(null, arguments);\n    };\n  };\n\n  async.times = function (count, iterator, callback) {\n    var counter = [];\n\n    for (var i = 0; i < count; i++) {\n      counter.push(i);\n    }\n\n    return async.map(counter, iterator, callback);\n  };\n\n  async.timesSeries = function (count, iterator, callback) {\n    var counter = [];\n\n    for (var i = 0; i < count; i++) {\n      counter.push(i);\n    }\n\n    return async.mapSeries(counter, iterator, callback);\n  };\n\n  async.compose = function ()\n  /* functions... */\n  {\n    var fns = Array.prototype.reverse.call(arguments);\n    return function () {\n      var that = this;\n      var args = Array.prototype.slice.call(arguments);\n      var callback = args.pop();\n      async.reduce(fns, args, function (newargs, fn, cb) {\n        fn.apply(that, newargs.concat([function () {\n          var err = arguments[0];\n          var nextargs = Array.prototype.slice.call(arguments, 1);\n          cb(err, nextargs);\n        }]));\n      }, function (err, results) {\n        callback.apply(that, [err].concat(results));\n      });\n    };\n  };\n\n  var _applyEach = function _applyEach(eachfn, fns\n  /*args...*/\n  ) {\n    var go = function go() {\n      var that = this;\n      var args = Array.prototype.slice.call(arguments);\n      var callback = args.pop();\n      return eachfn(fns, function (fn, cb) {\n        fn.apply(that, args.concat([cb]));\n      }, callback);\n    };\n\n    if (arguments.length > 2) {\n      var args = Array.prototype.slice.call(arguments, 2);\n      return go.apply(this, args);\n    } else {\n      return go;\n    }\n  };\n\n  async.applyEach = doParallel(_applyEach);\n  async.applyEachSeries = doSeries(_applyEach);\n\n  async.forever = function (fn, callback) {\n    function next(err) {\n      if (err) {\n        if (callback) {\n          return callback(err);\n        }\n\n        throw err;\n      }\n\n      fn(next);\n    }\n\n    next();\n  }; // AMD / RequireJS\n\n\n  if (typeof define !== 'undefined' && define.amd) {\n    define([], function () {\n      return async;\n    });\n  } // Node.js\n  else if (typeof module !== 'undefined' && module.exports) {\n      module.exports = async;\n    } // included directly via <script> tag\n    else {\n        root.async = async;\n      }\n})();","map":null,"metadata":{},"sourceType":"script"}