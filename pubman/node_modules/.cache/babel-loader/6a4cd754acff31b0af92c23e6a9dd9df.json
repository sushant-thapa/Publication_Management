{"ast":null,"code":"/**\n * Self-balancing binary search tree using the AVL implementation\n */\nvar BinarySearchTree = require('./bst'),\n    customUtils = require('./customUtils'),\n    util = require('util'),\n    _ = require('underscore');\n/**\n * Constructor\n * We can't use a direct pointer to the root node (as in the simple binary search tree)\n * as the root will change during tree rotations\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\n\n\nfunction AVLTree(options) {\n  this.tree = new _AVLTree(options);\n}\n/**\n * Constructor of the internal AVLTree\n * @param {Object} options Optional\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Key}      options.key Initialize this BST's key with key\n * @param {Value}    options.value Initialize this BST's data with [value]\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\n\n\nfunction _AVLTree(options) {\n  options = options || {};\n  this.left = null;\n  this.right = null;\n  this.parent = options.parent !== undefined ? options.parent : null;\n\n  if (options.hasOwnProperty('key')) {\n    this.key = options.key;\n  }\n\n  this.data = options.hasOwnProperty('value') ? [options.value] : [];\n  this.unique = options.unique || false;\n  this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;\n  this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;\n}\n/**\n * Inherit basic functions from the basic binary search tree\n */\n\n\nutil.inherits(_AVLTree, BinarySearchTree);\n/**\n * Keep a pointer to the internal tree constructor for testing purposes\n */\n\nAVLTree._AVLTree = _AVLTree;\n/**\n * Check the recorded height is correct for every node\n * Throws if one height doesn't match\n */\n\n_AVLTree.prototype.checkHeightCorrect = function () {\n  var leftH, rightH;\n\n  if (!this.hasOwnProperty('key')) {\n    return;\n  } // Empty tree\n\n\n  if (this.left && this.left.height === undefined) {\n    throw new Error(\"Undefined height for node \" + this.left.key);\n  }\n\n  if (this.right && this.right.height === undefined) {\n    throw new Error(\"Undefined height for node \" + this.right.key);\n  }\n\n  if (this.height === undefined) {\n    throw new Error(\"Undefined height for node \" + this.key);\n  }\n\n  leftH = this.left ? this.left.height : 0;\n  rightH = this.right ? this.right.height : 0;\n\n  if (this.height !== 1 + Math.max(leftH, rightH)) {\n    throw new Error(\"Height constraint failed for node \" + this.key);\n  }\n\n  if (this.left) {\n    this.left.checkHeightCorrect();\n  }\n\n  if (this.right) {\n    this.right.checkHeightCorrect();\n  }\n};\n/**\n * Return the balance factor\n */\n\n\n_AVLTree.prototype.balanceFactor = function () {\n  var leftH = this.left ? this.left.height : 0,\n      rightH = this.right ? this.right.height : 0;\n  return leftH - rightH;\n};\n/**\n * Check that the balance factors are all between -1 and 1\n */\n\n\n_AVLTree.prototype.checkBalanceFactors = function () {\n  if (Math.abs(this.balanceFactor()) > 1) {\n    throw new Error('Tree is unbalanced at node ' + this.key);\n  }\n\n  if (this.left) {\n    this.left.checkBalanceFactors();\n  }\n\n  if (this.right) {\n    this.right.checkBalanceFactors();\n  }\n};\n/**\n * When checking if the BST conditions are met, also check that the heights are correct\n * and the tree is balanced\n */\n\n\n_AVLTree.prototype.checkIsAVLT = function () {\n  _AVLTree.super_.prototype.checkIsBST.call(this);\n\n  this.checkHeightCorrect();\n  this.checkBalanceFactors();\n};\n\nAVLTree.prototype.checkIsAVLT = function () {\n  this.tree.checkIsAVLT();\n};\n/**\n * Perform a right rotation of the tree if possible\n * and return the root of the resulting tree\n * The resulting tree's nodes' heights are also updated\n */\n\n\n_AVLTree.prototype.rightRotation = function () {\n  var q = this,\n      p = this.left,\n      b,\n      ah,\n      bh,\n      ch;\n\n  if (!p) {\n    return this;\n  } // No change\n\n\n  b = p.right; // Alter tree structure\n\n  if (q.parent) {\n    p.parent = q.parent;\n\n    if (q.parent.left === q) {\n      q.parent.left = p;\n    } else {\n      q.parent.right = p;\n    }\n  } else {\n    p.parent = null;\n  }\n\n  p.right = q;\n  q.parent = p;\n  q.left = b;\n\n  if (b) {\n    b.parent = q;\n  } // Update heights\n\n\n  ah = p.left ? p.left.height : 0;\n  bh = b ? b.height : 0;\n  ch = q.right ? q.right.height : 0;\n  q.height = Math.max(bh, ch) + 1;\n  p.height = Math.max(ah, q.height) + 1;\n  return p;\n};\n/**\n * Perform a left rotation of the tree if possible\n * and return the root of the resulting tree\n * The resulting tree's nodes' heights are also updated\n */\n\n\n_AVLTree.prototype.leftRotation = function () {\n  var p = this,\n      q = this.right,\n      b,\n      ah,\n      bh,\n      ch;\n\n  if (!q) {\n    return this;\n  } // No change\n\n\n  b = q.left; // Alter tree structure\n\n  if (p.parent) {\n    q.parent = p.parent;\n\n    if (p.parent.left === p) {\n      p.parent.left = q;\n    } else {\n      p.parent.right = q;\n    }\n  } else {\n    q.parent = null;\n  }\n\n  q.left = p;\n  p.parent = q;\n  p.right = b;\n\n  if (b) {\n    b.parent = p;\n  } // Update heights\n\n\n  ah = p.left ? p.left.height : 0;\n  bh = b ? b.height : 0;\n  ch = q.right ? q.right.height : 0;\n  p.height = Math.max(ah, bh) + 1;\n  q.height = Math.max(ch, p.height) + 1;\n  return q;\n};\n/**\n * Modify the tree if its right subtree is too small compared to the left\n * Return the new root if any\n */\n\n\n_AVLTree.prototype.rightTooSmall = function () {\n  if (this.balanceFactor() <= 1) {\n    return this;\n  } // Right is not too small, don't change\n\n\n  if (this.left.balanceFactor() < 0) {\n    this.left.leftRotation();\n  }\n\n  return this.rightRotation();\n};\n/**\n * Modify the tree if its left subtree is too small compared to the right\n * Return the new root if any\n */\n\n\n_AVLTree.prototype.leftTooSmall = function () {\n  if (this.balanceFactor() >= -1) {\n    return this;\n  } // Left is not too small, don't change\n\n\n  if (this.right.balanceFactor() > 0) {\n    this.right.rightRotation();\n  }\n\n  return this.leftRotation();\n};\n/**\n * Rebalance the tree along the given path. The path is given reversed (as he was calculated\n * in the insert and delete functions).\n * Returns the new root of the tree\n * Of course, the first element of the path must be the root of the tree\n */\n\n\n_AVLTree.prototype.rebalanceAlongPath = function (path) {\n  var newRoot = this,\n      rotated,\n      i;\n\n  if (!this.hasOwnProperty('key')) {\n    delete this.height;\n    return this;\n  } // Empty tree\n  // Rebalance the tree and update all heights\n\n\n  for (i = path.length - 1; i >= 0; i -= 1) {\n    path[i].height = 1 + Math.max(path[i].left ? path[i].left.height : 0, path[i].right ? path[i].right.height : 0);\n\n    if (path[i].balanceFactor() > 1) {\n      rotated = path[i].rightTooSmall();\n\n      if (i === 0) {\n        newRoot = rotated;\n      }\n    }\n\n    if (path[i].balanceFactor() < -1) {\n      rotated = path[i].leftTooSmall();\n\n      if (i === 0) {\n        newRoot = rotated;\n      }\n    }\n  }\n\n  return newRoot;\n};\n/**\n * Insert a key, value pair in the tree while maintaining the AVL tree height constraint\n * Return a pointer to the root node, which may have changed\n */\n\n\n_AVLTree.prototype.insert = function (key, value) {\n  var insertPath = [],\n      currentNode = this; // Empty tree, insert as root\n\n  if (!this.hasOwnProperty('key')) {\n    this.key = key;\n    this.data.push(value);\n    this.height = 1;\n    return this;\n  } // Insert new leaf at the right place\n\n\n  while (true) {\n    // Same key: no change in the tree structure\n    if (currentNode.compareKeys(currentNode.key, key) === 0) {\n      if (currentNode.unique) {\n        var err = new Error(\"Can't insert key \" + key + \", it violates the unique constraint\");\n        err.key = key;\n        err.errorType = 'uniqueViolated';\n        throw err;\n      } else {\n        currentNode.data.push(value);\n      }\n\n      return this;\n    }\n\n    insertPath.push(currentNode);\n\n    if (currentNode.compareKeys(key, currentNode.key) < 0) {\n      if (!currentNode.left) {\n        insertPath.push(currentNode.createLeftChild({\n          key: key,\n          value: value\n        }));\n        break;\n      } else {\n        currentNode = currentNode.left;\n      }\n    } else {\n      if (!currentNode.right) {\n        insertPath.push(currentNode.createRightChild({\n          key: key,\n          value: value\n        }));\n        break;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n  }\n\n  return this.rebalanceAlongPath(insertPath);\n}; // Insert in the internal tree, update the pointer to the root if needed\n\n\nAVLTree.prototype.insert = function (key, value) {\n  var newTree = this.tree.insert(key, value); // If newTree is undefined, that means its structure was not modified\n\n  if (newTree) {\n    this.tree = newTree;\n  }\n};\n/**\n * Delete a key or just a value and return the new root of the tree\n * @param {Key} key\n * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n */\n\n\n_AVLTree.prototype.delete = function (key, value) {\n  var newData = [],\n      replaceWith,\n      self = this,\n      currentNode = this,\n      deletePath = [];\n\n  if (!this.hasOwnProperty('key')) {\n    return this;\n  } // Empty tree\n  // Either no match is found and the function will return from within the loop\n  // Or a match is found and deletePath will contain the path from the root to the node to delete after the loop\n\n\n  while (true) {\n    if (currentNode.compareKeys(key, currentNode.key) === 0) {\n      break;\n    }\n\n    deletePath.push(currentNode);\n\n    if (currentNode.compareKeys(key, currentNode.key) < 0) {\n      if (currentNode.left) {\n        currentNode = currentNode.left;\n      } else {\n        return this; // Key not found, no modification\n      }\n    } else {\n      // currentNode.compareKeys(key, currentNode.key) is > 0\n      if (currentNode.right) {\n        currentNode = currentNode.right;\n      } else {\n        return this; // Key not found, no modification\n      }\n    }\n  } // Delete only a value (no tree modification)\n\n\n  if (currentNode.data.length > 1 && value) {\n    currentNode.data.forEach(function (d) {\n      if (!currentNode.checkValueEquality(d, value)) {\n        newData.push(d);\n      }\n    });\n    currentNode.data = newData;\n    return this;\n  } // Delete a whole node\n  // Leaf\n\n\n  if (!currentNode.left && !currentNode.right) {\n    if (currentNode === this) {\n      // This leaf is also the root\n      delete currentNode.key;\n      currentNode.data = [];\n      delete currentNode.height;\n      return this;\n    } else {\n      if (currentNode.parent.left === currentNode) {\n        currentNode.parent.left = null;\n      } else {\n        currentNode.parent.right = null;\n      }\n\n      return this.rebalanceAlongPath(deletePath);\n    }\n  } // Node with only one child\n\n\n  if (!currentNode.left || !currentNode.right) {\n    replaceWith = currentNode.left ? currentNode.left : currentNode.right;\n\n    if (currentNode === this) {\n      // This node is also the root\n      replaceWith.parent = null;\n      return replaceWith; // height of replaceWith is necessarily 1 because the tree was balanced before deletion\n    } else {\n      if (currentNode.parent.left === currentNode) {\n        currentNode.parent.left = replaceWith;\n        replaceWith.parent = currentNode.parent;\n      } else {\n        currentNode.parent.right = replaceWith;\n        replaceWith.parent = currentNode.parent;\n      }\n\n      return this.rebalanceAlongPath(deletePath);\n    }\n  } // Node with two children\n  // Use the in-order predecessor (no need to randomize since we actively rebalance)\n\n\n  deletePath.push(currentNode);\n  replaceWith = currentNode.left; // Special case: the in-order predecessor is right below the node to delete\n\n  if (!replaceWith.right) {\n    currentNode.key = replaceWith.key;\n    currentNode.data = replaceWith.data;\n    currentNode.left = replaceWith.left;\n\n    if (replaceWith.left) {\n      replaceWith.left.parent = currentNode;\n    }\n\n    return this.rebalanceAlongPath(deletePath);\n  } // After this loop, replaceWith is the right-most leaf in the left subtree\n  // and deletePath the path from the root (inclusive) to replaceWith (exclusive)\n\n\n  while (true) {\n    if (replaceWith.right) {\n      deletePath.push(replaceWith);\n      replaceWith = replaceWith.right;\n    } else {\n      break;\n    }\n  }\n\n  currentNode.key = replaceWith.key;\n  currentNode.data = replaceWith.data;\n  replaceWith.parent.right = replaceWith.left;\n\n  if (replaceWith.left) {\n    replaceWith.left.parent = replaceWith.parent;\n  }\n\n  return this.rebalanceAlongPath(deletePath);\n}; // Delete a value\n\n\nAVLTree.prototype.delete = function (key, value) {\n  var newTree = this.tree.delete(key, value); // If newTree is undefined, that means its structure was not modified\n\n  if (newTree) {\n    this.tree = newTree;\n  }\n};\n/**\n * Other functions we want to use on an AVLTree as if it were the internal _AVLTree\n */\n\n\n['getNumberOfKeys', 'search', 'betweenBounds', 'prettyPrint', 'executeOnEveryNode'].forEach(function (fn) {\n  AVLTree.prototype[fn] = function () {\n    return this.tree[fn].apply(this.tree, arguments);\n  };\n}); // Interface\n\nmodule.exports = AVLTree;","map":null,"metadata":{},"sourceType":"script"}