{"ast":null,"code":"/**\n * Handle models (i.e. docs)\n * Serialization/deserialization\n * Copying\n * Querying, update\n */\nvar util = require('util'),\n    _ = require('underscore'),\n    modifierFunctions = {},\n    lastStepModifierFunctions = {},\n    comparisonFunctions = {},\n    logicalOperators = {},\n    arrayComparisonFunctions = {};\n/**\n * Check a key, throw an error if the key is non valid\n * @param {String} k key\n * @param {Model} v value, needed to treat the Date edge case\n * Non-treatable edge cases here: if part of the object if of the form { $$date: number } or { $$deleted: true }\n * Its serialized-then-deserialized version it will transformed into a Date object\n * But you really need to want it to trigger such behaviour, even when warned not to use '$' at the beginning of the field names...\n */\n\n\nfunction checkKey(k, v) {\n  if (typeof k === 'number') {\n    k = k.toString();\n  }\n\n  if (k[0] === '$' && !(k === '$$date' && typeof v === 'number') && !(k === '$$deleted' && v === true) && !(k === '$$indexCreated') && !(k === '$$indexRemoved')) {\n    throw new Error('Field names cannot begin with the $ character');\n  }\n\n  if (k.indexOf('.') !== -1) {\n    throw new Error('Field names cannot contain a .');\n  }\n}\n/**\n * Check a DB object and throw an error if it's not valid\n * Works by applying the above checkKey function to all fields recursively\n */\n\n\nfunction checkObject(obj) {\n  if (util.isArray(obj)) {\n    obj.forEach(function (o) {\n      checkObject(o);\n    });\n  }\n\n  if (typeof obj === 'object' && obj !== null) {\n    Object.keys(obj).forEach(function (k) {\n      checkKey(k, obj[k]);\n      checkObject(obj[k]);\n    });\n  }\n}\n/**\n * Serialize an object to be persisted to a one-line string\n * For serialization/deserialization, we use the native JSON parser and not eval or Function\n * That gives us less freedom but data entered in the database may come from users\n * so eval and the like are not safe\n * Accepted primitive types: Number, String, Boolean, Date, null\n * Accepted secondary types: Objects, Arrays\n */\n\n\nfunction serialize(obj) {\n  var res;\n  res = JSON.stringify(obj, function (k, v) {\n    checkKey(k, v);\n\n    if (v === undefined) {\n      return undefined;\n    }\n\n    if (v === null) {\n      return null;\n    } // Hackish way of checking if object is Date (this way it works between execution contexts in node-webkit).\n    // We can't use value directly because for dates it is already string in this function (date.toJSON was already called), so we use this\n\n\n    if (typeof this[k].getTime === 'function') {\n      return {\n        $$date: this[k].getTime()\n      };\n    }\n\n    return v;\n  });\n  return res;\n}\n/**\n * From a one-line representation of an object generate by the serialize function\n * Return the object itself\n */\n\n\nfunction deserialize(rawData) {\n  return JSON.parse(rawData, function (k, v) {\n    if (k === '$$date') {\n      return new Date(v);\n    }\n\n    if (typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || v === null) {\n      return v;\n    }\n\n    if (v && v.$$date) {\n      return v.$$date;\n    }\n\n    return v;\n  });\n}\n/**\n * Deep copy a DB object\n * The optional strictKeys flag (defaulting to false) indicates whether to copy everything or only fields\n * where the keys are valid, i.e. don't begin with $ and don't contain a .\n */\n\n\nfunction deepCopy(obj, strictKeys) {\n  var res;\n\n  if (typeof obj === 'boolean' || typeof obj === 'number' || typeof obj === 'string' || obj === null || util.isDate(obj)) {\n    return obj;\n  }\n\n  if (util.isArray(obj)) {\n    res = [];\n    obj.forEach(function (o) {\n      res.push(deepCopy(o, strictKeys));\n    });\n    return res;\n  }\n\n  if (typeof obj === 'object') {\n    res = {};\n    Object.keys(obj).forEach(function (k) {\n      if (!strictKeys || k[0] !== '$' && k.indexOf('.') === -1) {\n        res[k] = deepCopy(obj[k], strictKeys);\n      }\n    });\n    return res;\n  }\n\n  return undefined; // For now everything else is undefined. We should probably throw an error instead\n}\n/**\n * Tells if an object is a primitive type or a \"real\" object\n * Arrays are considered primitive\n */\n\n\nfunction isPrimitiveType(obj) {\n  return typeof obj === 'boolean' || typeof obj === 'number' || typeof obj === 'string' || obj === null || util.isDate(obj) || util.isArray(obj);\n}\n/**\n * Utility functions for comparing things\n * Assumes type checking was already done (a and b already have the same type)\n * compareNSB works for numbers, strings and booleans\n */\n\n\nfunction compareNSB(a, b) {\n  if (a < b) {\n    return -1;\n  }\n\n  if (a > b) {\n    return 1;\n  }\n\n  return 0;\n}\n\nfunction compareArrays(a, b) {\n  var i, comp;\n\n  for (i = 0; i < Math.min(a.length, b.length); i += 1) {\n    comp = compareThings(a[i], b[i]);\n\n    if (comp !== 0) {\n      return comp;\n    }\n  } // Common section was identical, longest one wins\n\n\n  return compareNSB(a.length, b.length);\n}\n/**\n * Compare { things U undefined }\n * Things are defined as any native types (string, number, boolean, null, date) and objects\n * We need to compare with undefined as it will be used in indexes\n * In the case of objects and arrays, we deep-compare\n * If two objects dont have the same type, the (arbitrary) type hierarchy is: undefined, null, number, strings, boolean, dates, arrays, objects\n * Return -1 if a < b, 1 if a > b and 0 if a = b (note that equality here is NOT the same as defined in areThingsEqual!)\n *\n * @param {Function} _compareStrings String comparing function, returning -1, 0 or 1, overriding default string comparison (useful for languages with accented letters)\n */\n\n\nfunction compareThings(a, b, _compareStrings) {\n  var aKeys,\n      bKeys,\n      comp,\n      i,\n      compareStrings = _compareStrings || compareNSB; // undefined\n\n  if (a === undefined) {\n    return b === undefined ? 0 : -1;\n  }\n\n  if (b === undefined) {\n    return a === undefined ? 0 : 1;\n  } // null\n\n\n  if (a === null) {\n    return b === null ? 0 : -1;\n  }\n\n  if (b === null) {\n    return a === null ? 0 : 1;\n  } // Numbers\n\n\n  if (typeof a === 'number') {\n    return typeof b === 'number' ? compareNSB(a, b) : -1;\n  }\n\n  if (typeof b === 'number') {\n    return typeof a === 'number' ? compareNSB(a, b) : 1;\n  } // Strings\n\n\n  if (typeof a === 'string') {\n    return typeof b === 'string' ? compareStrings(a, b) : -1;\n  }\n\n  if (typeof b === 'string') {\n    return typeof a === 'string' ? compareStrings(a, b) : 1;\n  } // Booleans\n\n\n  if (typeof a === 'boolean') {\n    return typeof b === 'boolean' ? compareNSB(a, b) : -1;\n  }\n\n  if (typeof b === 'boolean') {\n    return typeof a === 'boolean' ? compareNSB(a, b) : 1;\n  } // Dates\n\n\n  if (util.isDate(a)) {\n    return util.isDate(b) ? compareNSB(a.getTime(), b.getTime()) : -1;\n  }\n\n  if (util.isDate(b)) {\n    return util.isDate(a) ? compareNSB(a.getTime(), b.getTime()) : 1;\n  } // Arrays (first element is most significant and so on)\n\n\n  if (util.isArray(a)) {\n    return util.isArray(b) ? compareArrays(a, b) : -1;\n  }\n\n  if (util.isArray(b)) {\n    return util.isArray(a) ? compareArrays(a, b) : 1;\n  } // Objects\n\n\n  aKeys = Object.keys(a).sort();\n  bKeys = Object.keys(b).sort();\n\n  for (i = 0; i < Math.min(aKeys.length, bKeys.length); i += 1) {\n    comp = compareThings(a[aKeys[i]], b[bKeys[i]]);\n\n    if (comp !== 0) {\n      return comp;\n    }\n  }\n\n  return compareNSB(aKeys.length, bKeys.length);\n} // ==============================================================\n// Updating documents\n// ==============================================================\n\n/**\n * The signature of modifier functions is as follows\n * Their structure is always the same: recursively follow the dot notation while creating\n * the nested documents if needed, then apply the \"last step modifier\"\n * @param {Object} obj The model to modify\n * @param {String} field Can contain dots, in that case that means we will set a subfield recursively\n * @param {Model} value\n */\n\n/**\n * Set a field to a new value\n */\n\n\nlastStepModifierFunctions.$set = function (obj, field, value) {\n  obj[field] = value;\n};\n/**\n * Unset a field\n */\n\n\nlastStepModifierFunctions.$unset = function (obj, field, value) {\n  delete obj[field];\n};\n/**\n * Push an element to the end of an array field\n * Optional modifier $each instead of value to push several values\n * Optional modifier $slice to slice the resulting array, see https://docs.mongodb.org/manual/reference/operator/update/slice/\n * DiffÃ©reence with MongoDB: if $slice is specified and not $each, we act as if value is an empty array\n */\n\n\nlastStepModifierFunctions.$push = function (obj, field, value) {\n  // Create the array if it doesn't exist\n  if (!obj.hasOwnProperty(field)) {\n    obj[field] = [];\n  }\n\n  if (!util.isArray(obj[field])) {\n    throw new Error(\"Can't $push an element on non-array values\");\n  }\n\n  if (value !== null && typeof value === 'object' && value.$slice && value.$each === undefined) {\n    value.$each = [];\n  }\n\n  if (value !== null && typeof value === 'object' && value.$each) {\n    if (Object.keys(value).length >= 3 || Object.keys(value).length === 2 && value.$slice === undefined) {\n      throw new Error(\"Can only use $slice in cunjunction with $each when $push to array\");\n    }\n\n    if (!util.isArray(value.$each)) {\n      throw new Error(\"$each requires an array value\");\n    }\n\n    value.$each.forEach(function (v) {\n      obj[field].push(v);\n    });\n\n    if (value.$slice === undefined || typeof value.$slice !== 'number') {\n      return;\n    }\n\n    if (value.$slice === 0) {\n      obj[field] = [];\n    } else {\n      var start,\n          end,\n          n = obj[field].length;\n\n      if (value.$slice < 0) {\n        start = Math.max(0, n + value.$slice);\n        end = n;\n      } else if (value.$slice > 0) {\n        start = 0;\n        end = Math.min(n, value.$slice);\n      }\n\n      obj[field] = obj[field].slice(start, end);\n    }\n  } else {\n    obj[field].push(value);\n  }\n};\n/**\n * Add an element to an array field only if it is not already in it\n * No modification if the element is already in the array\n * Note that it doesn't check whether the original array contains duplicates\n */\n\n\nlastStepModifierFunctions.$addToSet = function (obj, field, value) {\n  var addToSet = true; // Create the array if it doesn't exist\n\n  if (!obj.hasOwnProperty(field)) {\n    obj[field] = [];\n  }\n\n  if (!util.isArray(obj[field])) {\n    throw new Error(\"Can't $addToSet an element on non-array values\");\n  }\n\n  if (value !== null && typeof value === 'object' && value.$each) {\n    if (Object.keys(value).length > 1) {\n      throw new Error(\"Can't use another field in conjunction with $each\");\n    }\n\n    if (!util.isArray(value.$each)) {\n      throw new Error(\"$each requires an array value\");\n    }\n\n    value.$each.forEach(function (v) {\n      lastStepModifierFunctions.$addToSet(obj, field, v);\n    });\n  } else {\n    obj[field].forEach(function (v) {\n      if (compareThings(v, value) === 0) {\n        addToSet = false;\n      }\n    });\n\n    if (addToSet) {\n      obj[field].push(value);\n    }\n  }\n};\n/**\n * Remove the first or last element of an array\n */\n\n\nlastStepModifierFunctions.$pop = function (obj, field, value) {\n  if (!util.isArray(obj[field])) {\n    throw new Error(\"Can't $pop an element from non-array values\");\n  }\n\n  if (typeof value !== 'number') {\n    throw new Error(value + \" isn't an integer, can't use it with $pop\");\n  }\n\n  if (value === 0) {\n    return;\n  }\n\n  if (value > 0) {\n    obj[field] = obj[field].slice(0, obj[field].length - 1);\n  } else {\n    obj[field] = obj[field].slice(1);\n  }\n};\n/**\n * Removes all instances of a value from an existing array\n */\n\n\nlastStepModifierFunctions.$pull = function (obj, field, value) {\n  var arr, i;\n\n  if (!util.isArray(obj[field])) {\n    throw new Error(\"Can't $pull an element from non-array values\");\n  }\n\n  arr = obj[field];\n\n  for (i = arr.length - 1; i >= 0; i -= 1) {\n    if (match(arr[i], value)) {\n      arr.splice(i, 1);\n    }\n  }\n};\n/**\n * Increment a numeric field's value\n */\n\n\nlastStepModifierFunctions.$inc = function (obj, field, value) {\n  if (typeof value !== 'number') {\n    throw new Error(value + \" must be a number\");\n  }\n\n  if (typeof obj[field] !== 'number') {\n    if (!_.has(obj, field)) {\n      obj[field] = value;\n    } else {\n      throw new Error(\"Don't use the $inc modifier on non-number fields\");\n    }\n  } else {\n    obj[field] += value;\n  }\n};\n/**\n * Updates the value of the field, only if specified field is greater than the current value of the field\n */\n\n\nlastStepModifierFunctions.$max = function (obj, field, value) {\n  if (typeof obj[field] === 'undefined') {\n    obj[field] = value;\n  } else if (value > obj[field]) {\n    obj[field] = value;\n  }\n};\n/**\n * Updates the value of the field, only if specified field is smaller than the current value of the field\n */\n\n\nlastStepModifierFunctions.$min = function (obj, field, value) {\n  if (typeof obj[field] === 'undefined') {\n    obj[field] = value;\n  } else if (value < obj[field]) {\n    obj[field] = value;\n  }\n}; // Given its name, create the complete modifier function\n\n\nfunction createModifierFunction(modifier) {\n  return function (obj, field, value) {\n    var fieldParts = typeof field === 'string' ? field.split('.') : field;\n\n    if (fieldParts.length === 1) {\n      lastStepModifierFunctions[modifier](obj, field, value);\n    } else {\n      if (obj[fieldParts[0]] === undefined) {\n        if (modifier === '$unset') {\n          return;\n        } // Bad looking specific fix, needs to be generalized modifiers that behave like $unset are implemented\n\n\n        obj[fieldParts[0]] = {};\n      }\n\n      modifierFunctions[modifier](obj[fieldParts[0]], fieldParts.slice(1), value);\n    }\n  };\n} // Actually create all modifier functions\n\n\nObject.keys(lastStepModifierFunctions).forEach(function (modifier) {\n  modifierFunctions[modifier] = createModifierFunction(modifier);\n});\n/**\n * Modify a DB object according to an update query\n */\n\nfunction modify(obj, updateQuery) {\n  var keys = Object.keys(updateQuery),\n      firstChars = _.map(keys, function (item) {\n    return item[0];\n  }),\n      dollarFirstChars = _.filter(firstChars, function (c) {\n    return c === '$';\n  }),\n      newDoc,\n      modifiers;\n\n  if (keys.indexOf('_id') !== -1 && updateQuery._id !== obj._id) {\n    throw new Error(\"You cannot change a document's _id\");\n  }\n\n  if (dollarFirstChars.length !== 0 && dollarFirstChars.length !== firstChars.length) {\n    throw new Error(\"You cannot mix modifiers and normal fields\");\n  }\n\n  if (dollarFirstChars.length === 0) {\n    // Simply replace the object with the update query contents\n    newDoc = deepCopy(updateQuery);\n    newDoc._id = obj._id;\n  } else {\n    // Apply modifiers\n    modifiers = _.uniq(keys);\n    newDoc = deepCopy(obj);\n    modifiers.forEach(function (m) {\n      var keys;\n\n      if (!modifierFunctions[m]) {\n        throw new Error(\"Unknown modifier \" + m);\n      } // Can't rely on Object.keys throwing on non objects since ES6\n      // Not 100% satisfying as non objects can be interpreted as objects but no false negatives so we can live with it\n\n\n      if (typeof updateQuery[m] !== 'object') {\n        throw new Error(\"Modifier \" + m + \"'s argument must be an object\");\n      }\n\n      keys = Object.keys(updateQuery[m]);\n      keys.forEach(function (k) {\n        modifierFunctions[m](newDoc, k, updateQuery[m][k]);\n      });\n    });\n  } // Check result is valid and return it\n\n\n  checkObject(newDoc);\n\n  if (obj._id !== newDoc._id) {\n    throw new Error(\"You can't change a document's _id\");\n  }\n\n  return newDoc;\n}\n\n; // ==============================================================\n// Finding documents\n// ==============================================================\n\n/**\n * Get a value from object with dot notation\n * @param {Object} obj\n * @param {String} field\n */\n\nfunction getDotValue(obj, field) {\n  var fieldParts = typeof field === 'string' ? field.split('.') : field,\n      i,\n      objs;\n\n  if (!obj) {\n    return undefined;\n  } // field cannot be empty so that means we should return undefined so that nothing can match\n\n\n  if (fieldParts.length === 0) {\n    return obj;\n  }\n\n  if (fieldParts.length === 1) {\n    return obj[fieldParts[0]];\n  }\n\n  if (util.isArray(obj[fieldParts[0]])) {\n    // If the next field is an integer, return only this item of the array\n    i = parseInt(fieldParts[1], 10);\n\n    if (typeof i === 'number' && !isNaN(i)) {\n      return getDotValue(obj[fieldParts[0]][i], fieldParts.slice(2));\n    } // Return the array of values\n\n\n    objs = new Array();\n\n    for (i = 0; i < obj[fieldParts[0]].length; i += 1) {\n      objs.push(getDotValue(obj[fieldParts[0]][i], fieldParts.slice(1)));\n    }\n\n    return objs;\n  } else {\n    return getDotValue(obj[fieldParts[0]], fieldParts.slice(1));\n  }\n}\n/**\n * Check whether 'things' are equal\n * Things are defined as any native types (string, number, boolean, null, date) and objects\n * In the case of object, we check deep equality\n * Returns true if they are, false otherwise\n */\n\n\nfunction areThingsEqual(a, b) {\n  var aKeys, bKeys, i; // Strings, booleans, numbers, null\n\n  if (a === null || typeof a === 'string' || typeof a === 'boolean' || typeof a === 'number' || b === null || typeof b === 'string' || typeof b === 'boolean' || typeof b === 'number') {\n    return a === b;\n  } // Dates\n\n\n  if (util.isDate(a) || util.isDate(b)) {\n    return util.isDate(a) && util.isDate(b) && a.getTime() === b.getTime();\n  } // Arrays (no match since arrays are used as a $in)\n  // undefined (no match since they mean field doesn't exist and can't be serialized)\n\n\n  if (!(util.isArray(a) && util.isArray(b)) && (util.isArray(a) || util.isArray(b)) || a === undefined || b === undefined) {\n    return false;\n  } // General objects (check for deep equality)\n  // a and b should be objects at this point\n\n\n  try {\n    aKeys = Object.keys(a);\n    bKeys = Object.keys(b);\n  } catch (e) {\n    return false;\n  }\n\n  if (aKeys.length !== bKeys.length) {\n    return false;\n  }\n\n  for (i = 0; i < aKeys.length; i += 1) {\n    if (bKeys.indexOf(aKeys[i]) === -1) {\n      return false;\n    }\n\n    if (!areThingsEqual(a[aKeys[i]], b[aKeys[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Check that two values are comparable\n */\n\n\nfunction areComparable(a, b) {\n  if (typeof a !== 'string' && typeof a !== 'number' && !util.isDate(a) && typeof b !== 'string' && typeof b !== 'number' && !util.isDate(b)) {\n    return false;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Arithmetic and comparison operators\n * @param {Native value} a Value in the object\n * @param {Native value} b Value in the query\n */\n\n\ncomparisonFunctions.$lt = function (a, b) {\n  return areComparable(a, b) && a < b;\n};\n\ncomparisonFunctions.$lte = function (a, b) {\n  return areComparable(a, b) && a <= b;\n};\n\ncomparisonFunctions.$gt = function (a, b) {\n  return areComparable(a, b) && a > b;\n};\n\ncomparisonFunctions.$gte = function (a, b) {\n  return areComparable(a, b) && a >= b;\n};\n\ncomparisonFunctions.$ne = function (a, b) {\n  if (a === undefined) {\n    return true;\n  }\n\n  return !areThingsEqual(a, b);\n};\n\ncomparisonFunctions.$in = function (a, b) {\n  var i;\n\n  if (!util.isArray(b)) {\n    throw new Error(\"$in operator called with a non-array\");\n  }\n\n  for (i = 0; i < b.length; i += 1) {\n    if (areThingsEqual(a, b[i])) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\ncomparisonFunctions.$nin = function (a, b) {\n  if (!util.isArray(b)) {\n    throw new Error(\"$nin operator called with a non-array\");\n  }\n\n  return !comparisonFunctions.$in(a, b);\n};\n\ncomparisonFunctions.$regex = function (a, b) {\n  if (!util.isRegExp(b)) {\n    throw new Error(\"$regex operator called with non regular expression\");\n  }\n\n  if (typeof a !== 'string') {\n    return false;\n  } else {\n    return b.test(a);\n  }\n};\n\ncomparisonFunctions.$exists = function (value, exists) {\n  if (exists || exists === '') {\n    // This will be true for all values of exists except false, null, undefined and 0\n    exists = true; // That's strange behaviour (we should only use true/false) but that's the way Mongo does it...\n  } else {\n    exists = false;\n  }\n\n  if (value === undefined) {\n    return !exists;\n  } else {\n    return exists;\n  }\n}; // Specific to arrays\n\n\ncomparisonFunctions.$size = function (obj, value) {\n  if (!util.isArray(obj)) {\n    return false;\n  }\n\n  if (value % 1 !== 0) {\n    throw new Error(\"$size operator called without an integer\");\n  }\n\n  return obj.length == value;\n};\n\ncomparisonFunctions.$elemMatch = function (obj, value) {\n  if (!util.isArray(obj)) {\n    return false;\n  }\n\n  var i = obj.length;\n  var result = false; // Initialize result\n\n  while (i--) {\n    if (match(obj[i], value)) {\n      // If match for array element, return true\n      result = true;\n      break;\n    }\n  }\n\n  return result;\n};\n\narrayComparisonFunctions.$size = true;\narrayComparisonFunctions.$elemMatch = true;\n/**\n * Match any of the subqueries\n * @param {Model} obj\n * @param {Array of Queries} query\n */\n\nlogicalOperators.$or = function (obj, query) {\n  var i;\n\n  if (!util.isArray(query)) {\n    throw new Error(\"$or operator used without an array\");\n  }\n\n  for (i = 0; i < query.length; i += 1) {\n    if (match(obj, query[i])) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Match all of the subqueries\n * @param {Model} obj\n * @param {Array of Queries} query\n */\n\n\nlogicalOperators.$and = function (obj, query) {\n  var i;\n\n  if (!util.isArray(query)) {\n    throw new Error(\"$and operator used without an array\");\n  }\n\n  for (i = 0; i < query.length; i += 1) {\n    if (!match(obj, query[i])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Inverted match of the query\n * @param {Model} obj\n * @param {Query} query\n */\n\n\nlogicalOperators.$not = function (obj, query) {\n  return !match(obj, query);\n};\n/**\n * Use a function to match\n * @param {Model} obj\n * @param {Query} query\n */\n\n\nlogicalOperators.$where = function (obj, fn) {\n  var result;\n\n  if (!_.isFunction(fn)) {\n    throw new Error(\"$where operator used without a function\");\n  }\n\n  result = fn.call(obj);\n\n  if (!_.isBoolean(result)) {\n    throw new Error(\"$where function must return boolean\");\n  }\n\n  return result;\n};\n/**\n * Tell if a given document matches a query\n * @param {Object} obj Document to check\n * @param {Object} query\n */\n\n\nfunction match(obj, query) {\n  var queryKeys, queryKey, queryValue, i; // Primitive query against a primitive type\n  // This is a bit of a hack since we construct an object with an arbitrary key only to dereference it later\n  // But I don't have time for a cleaner implementation now\n\n  if (isPrimitiveType(obj) || isPrimitiveType(query)) {\n    return matchQueryPart({\n      needAKey: obj\n    }, 'needAKey', query);\n  } // Normal query\n\n\n  queryKeys = Object.keys(query);\n\n  for (i = 0; i < queryKeys.length; i += 1) {\n    queryKey = queryKeys[i];\n    queryValue = query[queryKey];\n\n    if (queryKey[0] === '$') {\n      if (!logicalOperators[queryKey]) {\n        throw new Error(\"Unknown logical operator \" + queryKey);\n      }\n\n      if (!logicalOperators[queryKey](obj, queryValue)) {\n        return false;\n      }\n    } else {\n      if (!matchQueryPart(obj, queryKey, queryValue)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n;\n/**\n * Match an object against a specific { key: value } part of a query\n * if the treatObjAsValue flag is set, don't try to match every part separately, but the array as a whole\n */\n\nfunction matchQueryPart(obj, queryKey, queryValue, treatObjAsValue) {\n  var objValue = getDotValue(obj, queryKey),\n      i,\n      keys,\n      firstChars,\n      dollarFirstChars; // Check if the value is an array if we don't force a treatment as value\n\n  if (util.isArray(objValue) && !treatObjAsValue) {\n    // If the queryValue is an array, try to perform an exact match\n    if (util.isArray(queryValue)) {\n      return matchQueryPart(obj, queryKey, queryValue, true);\n    } // Check if we are using an array-specific comparison function\n\n\n    if (queryValue !== null && typeof queryValue === 'object' && !util.isRegExp(queryValue)) {\n      keys = Object.keys(queryValue);\n\n      for (i = 0; i < keys.length; i += 1) {\n        if (arrayComparisonFunctions[keys[i]]) {\n          return matchQueryPart(obj, queryKey, queryValue, true);\n        }\n      }\n    } // If not, treat it as an array of { obj, query } where there needs to be at least one match\n\n\n    for (i = 0; i < objValue.length; i += 1) {\n      if (matchQueryPart({\n        k: objValue[i]\n      }, 'k', queryValue)) {\n        return true;\n      } // k here could be any string\n\n    }\n\n    return false;\n  } // queryValue is an actual object. Determine whether it contains comparison operators\n  // or only normal fields. Mixed objects are not allowed\n\n\n  if (queryValue !== null && typeof queryValue === 'object' && !util.isRegExp(queryValue) && !util.isArray(queryValue)) {\n    keys = Object.keys(queryValue);\n    firstChars = _.map(keys, function (item) {\n      return item[0];\n    });\n    dollarFirstChars = _.filter(firstChars, function (c) {\n      return c === '$';\n    });\n\n    if (dollarFirstChars.length !== 0 && dollarFirstChars.length !== firstChars.length) {\n      throw new Error(\"You cannot mix operators and normal fields\");\n    } // queryValue is an object of this form: { $comparisonOperator1: value1, ... }\n\n\n    if (dollarFirstChars.length > 0) {\n      for (i = 0; i < keys.length; i += 1) {\n        if (!comparisonFunctions[keys[i]]) {\n          throw new Error(\"Unknown comparison function \" + keys[i]);\n        }\n\n        if (!comparisonFunctions[keys[i]](objValue, queryValue[keys[i]])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  } // Using regular expressions with basic querying\n\n\n  if (util.isRegExp(queryValue)) {\n    return comparisonFunctions.$regex(objValue, queryValue);\n  } // queryValue is either a native value or a normal object\n  // Basic matching is possible\n\n\n  if (!areThingsEqual(objValue, queryValue)) {\n    return false;\n  }\n\n  return true;\n} // Interface\n\n\nmodule.exports.serialize = serialize;\nmodule.exports.deserialize = deserialize;\nmodule.exports.deepCopy = deepCopy;\nmodule.exports.checkObject = checkObject;\nmodule.exports.isPrimitiveType = isPrimitiveType;\nmodule.exports.modify = modify;\nmodule.exports.getDotValue = getDotValue;\nmodule.exports.match = match;\nmodule.exports.areThingsEqual = areThingsEqual;\nmodule.exports.compareThings = compareThings;","map":null,"metadata":{},"sourceType":"script"}