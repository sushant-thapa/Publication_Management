{"ast":null,"code":"//     Underscore.js 1.4.4\n//     http://underscorejs.org\n//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore may be freely distributed under the MIT license.\n(function () {\n  // Baseline setup\n  // --------------\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this; // Save the previous value of the `_` variable.\n\n  var previousUnderscore = root._; // Establish the object that gets returned to break out of a loop iteration.\n\n  var breaker = {}; // Save bytes in the minified (but not gzipped) version:\n\n  var ArrayProto = Array.prototype,\n      ObjProto = Object.prototype,\n      FuncProto = Function.prototype; // Create quick reference variables for speed access to core prototypes.\n\n  var push = ArrayProto.push,\n      slice = ArrayProto.slice,\n      concat = ArrayProto.concat,\n      toString = ObjProto.toString,\n      hasOwnProperty = ObjProto.hasOwnProperty; // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n\n  var nativeForEach = ArrayProto.forEach,\n      nativeMap = ArrayProto.map,\n      nativeReduce = ArrayProto.reduce,\n      nativeReduceRight = ArrayProto.reduceRight,\n      nativeFilter = ArrayProto.filter,\n      nativeEvery = ArrayProto.every,\n      nativeSome = ArrayProto.some,\n      nativeIndexOf = ArrayProto.indexOf,\n      nativeLastIndexOf = ArrayProto.lastIndexOf,\n      nativeIsArray = Array.isArray,\n      nativeKeys = Object.keys,\n      nativeBind = FuncProto.bind; // Create a safe reference to the Underscore object for use below.\n\n  var _ = function _(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  }; // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n\n\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n\n    exports._ = _;\n  } else {\n    root._ = _;\n  } // Current version.\n\n\n  _.VERSION = '1.4.4'; // Collection Functions\n  // --------------------\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n\n  var each = _.each = _.forEach = function (obj, iterator, context) {\n    if (obj == null) return;\n\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  }; // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n\n\n  _.map = _.collect = function (obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function (value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value'; // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n\n  _.reduce = _.foldl = _.inject = function (obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n\n    each(obj, function (value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  }; // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n\n\n  _.reduceRight = _.foldr = function (obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n\n    var length = obj.length;\n\n    if (length !== +length) {\n      var keys = _.keys(obj);\n\n      length = keys.length;\n    }\n\n    each(obj, function (value, index, list) {\n      index = keys ? keys[--length] : --length;\n\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  }; // Return the first value which passes a truth test. Aliased as `detect`.\n\n\n  _.find = _.detect = function (obj, iterator, context) {\n    var result;\n    any(obj, function (value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  }; // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n\n\n  _.filter = _.select = function (obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function (value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  }; // Return all the elements for which a truth test fails.\n\n\n  _.reject = function (obj, iterator, context) {\n    return _.filter(obj, function (value, index, list) {\n      return !iterator.call(context, value, index, list);\n    }, context);\n  }; // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n\n\n  _.every = _.all = function (obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function (value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  }; // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n\n\n  var any = _.some = _.any = function (obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function (value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  }; // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n\n\n  _.contains = _.include = function (obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function (value) {\n      return value === target;\n    });\n  }; // Invoke a method (with arguments) on every item in a collection.\n\n\n  _.invoke = function (obj, method) {\n    var args = slice.call(arguments, 2);\n\n    var isFunc = _.isFunction(method);\n\n    return _.map(obj, function (value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  }; // Convenience version of a common use case of `map`: fetching a property.\n\n\n  _.pluck = function (obj, key) {\n    return _.map(obj, function (value) {\n      return value[key];\n    });\n  }; // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n\n\n  _.where = function (obj, attrs, first) {\n    if (_.isEmpty(attrs)) return first ? null : [];\n    return _[first ? 'find' : 'filter'](obj, function (value) {\n      for (var key in attrs) {\n        if (attrs[key] !== value[key]) return false;\n      }\n\n      return true;\n    });\n  }; // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n\n\n  _.findWhere = function (obj, attrs) {\n    return _.where(obj, attrs, true);\n  }; // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See: https://bugs.webkit.org/show_bug.cgi?id=80797\n\n\n  _.max = function (obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {\n      computed: -Infinity,\n      value: -Infinity\n    };\n    each(obj, function (value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {\n        value: value,\n        computed: computed\n      });\n    });\n    return result.value;\n  }; // Return the minimum element (or element-based computation).\n\n\n  _.min = function (obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {\n      computed: Infinity,\n      value: Infinity\n    };\n    each(obj, function (value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {\n        value: value,\n        computed: computed\n      });\n    });\n    return result.value;\n  }; // Shuffle an array.\n\n\n  _.shuffle = function (obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function (value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  }; // An internal function to generate lookup iterators.\n\n\n  var lookupIterator = function lookupIterator(value) {\n    return _.isFunction(value) ? value : function (obj) {\n      return obj[value];\n    };\n  }; // Sort the object's values by a criterion produced by an iterator.\n\n\n  _.sortBy = function (obj, value, context) {\n    var iterator = lookupIterator(value);\n    return _.pluck(_.map(obj, function (value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iterator.call(context, value, index, list)\n      };\n    }).sort(function (left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n\n      return left.index < right.index ? -1 : 1;\n    }), 'value');\n  }; // An internal function used for aggregate \"group by\" operations.\n\n\n  var group = function group(obj, value, context, behavior) {\n    var result = {};\n    var iterator = lookupIterator(value || _.identity);\n    each(obj, function (value, index) {\n      var key = iterator.call(context, value, index, obj);\n      behavior(result, key, value);\n    });\n    return result;\n  }; // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n\n\n  _.groupBy = function (obj, value, context) {\n    return group(obj, value, context, function (result, key, value) {\n      (_.has(result, key) ? result[key] : result[key] = []).push(value);\n    });\n  }; // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n\n\n  _.countBy = function (obj, value, context) {\n    return group(obj, value, context, function (result, key) {\n      if (!_.has(result, key)) result[key] = 0;\n      result[key]++;\n    });\n  }; // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n\n\n  _.sortedIndex = function (array, obj, iterator, context) {\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0,\n        high = array.length;\n\n    while (low < high) {\n      var mid = low + high >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n\n    return low;\n  }; // Safely convert anything iterable into a real, live array.\n\n\n  _.toArray = function (obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  }; // Return the number of elements in an object.\n\n\n  _.size = function (obj) {\n    if (obj == null) return 0;\n    return obj.length === +obj.length ? obj.length : _.keys(obj).length;\n  }; // Array Functions\n  // ---------------\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n\n\n  _.first = _.head = _.take = function (array, n, guard) {\n    if (array == null) return void 0;\n    return n != null && !guard ? slice.call(array, 0, n) : array[0];\n  }; // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n\n\n  _.initial = function (array, n, guard) {\n    return slice.call(array, 0, array.length - (n == null || guard ? 1 : n));\n  }; // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n\n\n  _.last = function (array, n, guard) {\n    if (array == null) return void 0;\n\n    if (n != null && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  }; // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n\n\n  _.rest = _.tail = _.drop = function (array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  }; // Trim out all falsy values from an array.\n\n\n  _.compact = function (array) {\n    return _.filter(array, _.identity);\n  }; // Internal implementation of a recursive `flatten` function.\n\n\n  var flatten = function flatten(input, shallow, output) {\n    each(input, function (value) {\n      if (_.isArray(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  }; // Return a completely flattened version of an array.\n\n\n  _.flatten = function (array, shallow) {\n    return flatten(array, shallow, []);\n  }; // Return a version of the array that does not contain the specified value(s).\n\n\n  _.without = function (array) {\n    return _.difference(array, slice.call(arguments, 1));\n  }; // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n\n\n  _.uniq = _.unique = function (array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function (value, index) {\n      if (isSorted ? !index || seen[seen.length - 1] !== value : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  }; // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n\n\n  _.union = function () {\n    return _.uniq(concat.apply(ArrayProto, arguments));\n  }; // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n\n\n  _.intersection = function (array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function (item) {\n      return _.every(rest, function (other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  }; // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n\n\n  _.difference = function (array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function (value) {\n      return !_.contains(rest, value);\n    });\n  }; // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n\n\n  _.zip = function () {\n    var args = slice.call(arguments);\n\n    var length = _.max(_.pluck(args, 'length'));\n\n    var results = new Array(length);\n\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(args, \"\" + i);\n    }\n\n    return results;\n  }; // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n\n\n  _.object = function (list, values) {\n    if (list == null) return {};\n    var result = {};\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n\n    return result;\n  }; // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n\n\n  _.indexOf = function (array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0,\n        l = array.length;\n\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = isSorted < 0 ? Math.max(0, l + isSorted) : isSorted;\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n\n    for (; i < l; i++) {\n      if (array[i] === item) return i;\n    }\n\n    return -1;\n  }; // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n\n\n  _.lastIndexOf = function (array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n\n    var i = hasIndex ? from : array.length;\n\n    while (i--) {\n      if (array[i] === item) return i;\n    }\n\n    return -1;\n  }; // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n\n\n  _.range = function (start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n\n    step = arguments[2] || 1;\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while (idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  }; // Function (ahem) Functions\n  // ------------------\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n\n\n  _.bind = function (func, context) {\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    var args = slice.call(arguments, 2);\n    return function () {\n      return func.apply(context, args.concat(slice.call(arguments)));\n    };\n  }; // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context.\n\n\n  _.partial = function (func) {\n    var args = slice.call(arguments, 1);\n    return function () {\n      return func.apply(this, args.concat(slice.call(arguments)));\n    };\n  }; // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n\n\n  _.bindAll = function (obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length === 0) funcs = _.functions(obj);\n    each(funcs, function (f) {\n      obj[f] = _.bind(obj[f], obj);\n    });\n    return obj;\n  }; // Memoize an expensive function by storing its results.\n\n\n  _.memoize = function (func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function () {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : memo[key] = func.apply(this, arguments);\n    };\n  }; // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n\n\n  _.delay = function (func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function () {\n      return func.apply(null, args);\n    }, wait);\n  }; // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n\n\n  _.defer = function (func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  }; // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n\n\n  _.throttle = function (func, wait) {\n    var context, args, timeout, result;\n    var previous = 0;\n\n    var later = function later() {\n      previous = new Date();\n      timeout = null;\n      result = func.apply(context, args);\n    };\n\n    return function () {\n      var now = new Date();\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n      } else if (!timeout) {\n        timeout = setTimeout(later, remaining);\n      }\n\n      return result;\n    };\n  }; // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n\n\n  _.debounce = function (func, wait, immediate) {\n    var timeout, result;\n    return function () {\n      var context = this,\n          args = arguments;\n\n      var later = function later() {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n      };\n\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) result = func.apply(context, args);\n      return result;\n    };\n  }; // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n\n\n  _.once = function (func) {\n    var ran = false,\n        memo;\n    return function () {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  }; // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n\n\n  _.wrap = function (func, wrapper) {\n    return function () {\n      var args = [func];\n      push.apply(args, arguments);\n      return wrapper.apply(this, args);\n    };\n  }; // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n\n\n  _.compose = function () {\n    var funcs = arguments;\n    return function () {\n      var args = arguments;\n\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n\n      return args[0];\n    };\n  }; // Returns a function that will only be executed after being called N times.\n\n\n  _.after = function (times, func) {\n    if (times <= 0) return func();\n    return function () {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  }; // Object Functions\n  // ----------------\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n\n\n  _.keys = nativeKeys || function (obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n\n    for (var key in obj) {\n      if (_.has(obj, key)) keys[keys.length] = key;\n    }\n\n    return keys;\n  }; // Retrieve the values of an object's properties.\n\n\n  _.values = function (obj) {\n    var values = [];\n\n    for (var key in obj) {\n      if (_.has(obj, key)) values.push(obj[key]);\n    }\n\n    return values;\n  }; // Convert an object into a list of `[key, value]` pairs.\n\n\n  _.pairs = function (obj) {\n    var pairs = [];\n\n    for (var key in obj) {\n      if (_.has(obj, key)) pairs.push([key, obj[key]]);\n    }\n\n    return pairs;\n  }; // Invert the keys and values of an object. The values must be serializable.\n\n\n  _.invert = function (obj) {\n    var result = {};\n\n    for (var key in obj) {\n      if (_.has(obj, key)) result[obj[key]] = key;\n    }\n\n    return result;\n  }; // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n\n\n  _.functions = _.methods = function (obj) {\n    var names = [];\n\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n\n    return names.sort();\n  }; // Extend a given object with all the properties in passed-in object(s).\n\n\n  _.extend = function (obj) {\n    each(slice.call(arguments, 1), function (source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  }; // Return a copy of the object only containing the whitelisted properties.\n\n\n  _.pick = function (obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function (key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  }; // Return a copy of the object without the blacklisted properties.\n\n\n  _.omit = function (obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n\n    return copy;\n  }; // Fill in a given object with default properties.\n\n\n  _.defaults = function (obj) {\n    each(slice.call(arguments, 1), function (source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] == null) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  }; // Create a (shallow-cloned) duplicate of an object.\n\n\n  _.clone = function (obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  }; // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n\n\n  _.tap = function (obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  }; // Internal recursive comparison function for `isEqual`.\n\n\n  var eq = function eq(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b; // A strict comparison is necessary because `null == undefined`.\n\n    if (a == null || b == null) return a === b; // Unwrap any wrapped objects.\n\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped; // Compare `[[Class]]` names.\n\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;\n\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n\n      case '[object RegExp]':\n        return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;\n    }\n\n    if (typeof a != 'object' || typeof b != 'object') return false; // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n    var length = aStack.length;\n\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    } // Add the first object to the stack of traversed objects.\n\n\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0,\n        result = true; // Recursively compare objects and arrays.\n\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // from different frames are.\n      var aCtor = a.constructor,\n          bCtor = b.constructor;\n\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor)) {\n        return false;\n      } // Deep compare objects.\n\n\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++; // Deep compare each member.\n\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      } // Ensure that both objects contain the same number of properties.\n\n\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !size--) break;\n        }\n\n        result = !size;\n      }\n    } // Remove the first object from the stack of traversed objects.\n\n\n    aStack.pop();\n    bStack.pop();\n    return result;\n  }; // Perform a deep comparison to check if two objects are equal.\n\n\n  _.isEqual = function (a, b) {\n    return eq(a, b, [], []);\n  }; // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n\n\n  _.isEmpty = function (obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n\n    for (var key in obj) {\n      if (_.has(obj, key)) return false;\n    }\n\n    return true;\n  }; // Is a given value a DOM element?\n\n\n  _.isElement = function (obj) {\n    return !!(obj && obj.nodeType === 1);\n  }; // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n\n\n  _.isArray = nativeIsArray || function (obj) {\n    return toString.call(obj) == '[object Array]';\n  }; // Is a given variable an object?\n\n\n  _.isObject = function (obj) {\n    return obj === Object(obj);\n  }; // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n\n\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function (name) {\n    _['is' + name] = function (obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  }); // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function (obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  } // Optimize `isFunction` if appropriate.\n\n\n  if (typeof /./ !== 'function') {\n    _.isFunction = function (obj) {\n      return typeof obj === 'function';\n    };\n  } // Is a given object a finite number?\n\n\n  _.isFinite = function (obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  }; // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n\n\n  _.isNaN = function (obj) {\n    return _.isNumber(obj) && obj != +obj;\n  }; // Is a given value a boolean?\n\n\n  _.isBoolean = function (obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  }; // Is a given value equal to null?\n\n\n  _.isNull = function (obj) {\n    return obj === null;\n  }; // Is a given variable undefined?\n\n\n  _.isUndefined = function (obj) {\n    return obj === void 0;\n  }; // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n\n\n  _.has = function (obj, key) {\n    return hasOwnProperty.call(obj, key);\n  }; // Utility Functions\n  // -----------------\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n\n\n  _.noConflict = function () {\n    root._ = previousUnderscore;\n    return this;\n  }; // Keep the identity function around for default iterators.\n\n\n  _.identity = function (value) {\n    return value;\n  }; // Run a function **n** times.\n\n\n  _.times = function (n, iterator, context) {\n    var accum = Array(n);\n\n    for (var i = 0; i < n; i++) {\n      accum[i] = iterator.call(context, i);\n    }\n\n    return accum;\n  }; // Return a random integer between min and max (inclusive).\n\n\n  _.random = function (min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n\n    return min + Math.floor(Math.random() * (max - min + 1));\n  }; // List of HTML entities for escaping.\n\n\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;',\n      '/': '&#x2F;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape); // Regexes containing the keys and values listed immediately above.\n\n  var entityRegexes = {\n    escape: new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  }; // Functions for escaping and unescaping strings to/from HTML interpolation.\n\n  _.each(['escape', 'unescape'], function (method) {\n    _[method] = function (string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function (match) {\n        return entityMap[method][match];\n      });\n    };\n  }); // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n\n\n  _.result = function (object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  }; // Add your own custom functions to the Underscore object.\n\n\n  _.mixin = function (obj) {\n    each(_.functions(obj), function (name) {\n      var func = _[name] = obj[name];\n\n      _.prototype[name] = function () {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  }; // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n\n\n  var idCounter = 0;\n\n  _.uniqueId = function (prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  }; // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n\n\n  _.templateSettings = {\n    evaluate: /<%([\\s\\S]+?)%>/g,\n    interpolate: /<%=([\\s\\S]+?)%>/g,\n    escape: /<%-([\\s\\S]+?)%>/g\n  }; // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n\n  var noMatch = /(.)^/; // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n\n  var escapes = {\n    \"'\": \"'\",\n    '\\\\': '\\\\',\n    '\\r': 'r',\n    '\\n': 'n',\n    '\\t': 't',\n    \"\\u2028\": 'u2028',\n    \"\\u2029\": 'u2029'\n  };\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g; // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n\n  _.template = function (text, data, settings) {\n    var render;\n    settings = _.defaults({}, settings, _.templateSettings); // Combine delimiters into one regular expression via alternation.\n\n    var matcher = new RegExp([(settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source].join('|') + '|$', 'g'); // Compile the template source, escaping string literals appropriately.\n\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escaper, function (match) {\n        return '\\\\' + escapes[match];\n      });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\"; // If a variable is not specified, place data values in local scope.\n\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n    source = \"var __t,__p='',__j=Array.prototype.join,\" + \"print=function(){__p+=__j.call(arguments,'');};\\n\" + source + \"return __p;\\n\";\n\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n\n    var template = function template(data) {\n      return render.call(this, data, _);\n    }; // Provide the compiled function source as a convenience for precompilation.\n\n\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n    return template;\n  }; // Add a \"chain\" function, which will delegate to the wrapper.\n\n\n  _.chain = function (obj) {\n    return _(obj).chain();\n  }; // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n  // Helper function to continue chaining intermediate results.\n\n\n  var result = function result(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  }; // Add all of the Underscore functions to the wrapper object.\n\n\n  _.mixin(_); // Add all mutator Array functions to the wrapper.\n\n\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (name) {\n    var method = ArrayProto[name];\n\n    _.prototype[name] = function () {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  }); // Add all accessor Array functions to the wrapper.\n\n  each(['concat', 'join', 'slice'], function (name) {\n    var method = ArrayProto[name];\n\n    _.prototype[name] = function () {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n    // Start chaining a wrapped Underscore object.\n    chain: function chain() {\n      this._chain = true;\n      return this;\n    },\n    // Extracts the result from a wrapped and chained object.\n    value: function value() {\n      return this._wrapped;\n    }\n  });\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}