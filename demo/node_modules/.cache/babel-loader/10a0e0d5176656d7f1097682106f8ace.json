{"ast":null,"code":"/**\n * Specific customUtils for the browser, where we don't have access to the Crypto and Buffer modules\n */\n\n/**\n * Taken from the crypto-browserify module\n * https://github.com/dominictarr/crypto-browserify\n * NOTE: Math.random() does not guarantee \"cryptographic quality\" but we actually don't need it\n */\nfunction randomBytes(size) {\n  var bytes = new Array(size);\n  var r;\n\n  for (var i = 0, r; i < size; i++) {\n    if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n    bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;\n  }\n\n  return bytes;\n}\n/**\n * Taken from the base64-js module\n * https://github.com/beatgammit/base64-js/\n */\n\n\nfunction byteArrayToBase64(uint8) {\n  var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n      extraBytes = uint8.length % 3 // if we have 1 byte left, pad 2 bytes\n  ,\n      output = \"\",\n      temp,\n      length,\n      i;\n\n  function tripletToBase64(num) {\n    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n  }\n\n  ; // go through the array every three bytes, we'll deal with trailing stuff later\n\n  for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n    temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n    output += tripletToBase64(temp);\n  } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n  switch (extraBytes) {\n    case 1:\n      temp = uint8[uint8.length - 1];\n      output += lookup[temp >> 2];\n      output += lookup[temp << 4 & 0x3F];\n      output += '==';\n      break;\n\n    case 2:\n      temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];\n      output += lookup[temp >> 10];\n      output += lookup[temp >> 4 & 0x3F];\n      output += lookup[temp << 2 & 0x3F];\n      output += '=';\n      break;\n  }\n\n  return output;\n}\n/**\n * Return a random alphanumerical string of length len\n * There is a very small probability (less than 1/1,000,000) for the length to be less than len\n * (il the base64 conversion yields too many pluses and slashes) but\n * that's not an issue here\n * The probability of a collision is extremely small (need 3*10^12 documents to have one chance in a million of a collision)\n * See http://en.wikipedia.org/wiki/Birthday_problem\n */\n\n\nfunction uid(len) {\n  return byteArrayToBase64(randomBytes(Math.ceil(Math.max(8, len * 2)))).replace(/[+\\/]/g, '').slice(0, len);\n}\n\nmodule.exports.uid = uid;","map":null,"metadata":{},"sourceType":"script"}